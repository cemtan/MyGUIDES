<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>mse</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
  <!--
  @page { size: 8.27in 11.69in }
  H1  { font-family: "Verdana", sans-serif }
  H2  { font-family: "Verdana", sans-serif }
  H3  { font-family: "Verdana", sans-serif }
  H4  { font-family: "Verdana", sans-serif }
  P   { font-family: "Verdana", sans-serif; font-size: 11pt; margin-left: 40px; }
  PRE { font-family: "Courier", monospace;  font-size: 12pt; margin-left: 40px; }
  DT  { font-family: "Verdana", sans-serif; font-size: 11pt; margin-left: 40px; }
  LI  { font-family: "Verdana", sans-serif; font-size: 11pt; margin-left: 40px; }
  -->
  </style>

</head>
<body style="background-color: white">
<!--Start header -->
<!-- html created: 2023-03-07 10:20:39 +0000 oemId: 1 -->
<h1>mse</h1>
<p>Run a C-like script in a minishell environment</p>
<h1>Syntax</h1>
<pre>... | mse [setting options] [dump options] [env options] [filter options (when run as a filter)]
	[--load-library-file|-L &lt;library_name.mse&gt;] [--library-id|-I &lt;existing library id to share&gt;]
	[--] { &lt;main mse-script&gt;
	      | {--file|-f &lt;scriptfile1:file2:file3...&gt;    [arg1] [arg2] ...}
	      | {--file|-f &lt;scriptfile&gt;[::&lt;function_name&gt;] [arg1] [arg2] ...}
	      | {--call [&lt;library_name&gt;::]&lt;function_name&gt;  [arg1] [arg2] ...}
	      | {--eof &lt;end-marker&gt;&lt;CR&gt;&lt;script line 1&gt;&lt;CR&gt;&lt;script line 2&gt;&lt;CR&gt;&lt;. . .&gt;&lt;CR&gt;&lt;endMarker&gt;&lt;CR&gt; } }
	where
	setting options ::= [--escape-char|-e &lt;default @, 0 to disable&gt;] [--macro-symbol|-m &lt;default %, 0 to disable&gt;]
	                    [--left-delimiter-char|-D &lt;default {&gt;] [--command-separator|-C &lt;default ;&gt;
	                    [--ampersand-token &lt;default &amp;&gt;] [--pipe-token &lt;default |&gt;]
	                    [--double-quote-token|-Q &lt;default &quot;&gt;] [--single-quote-token|-q &lt;default &#39;&gt;]
	                    [--preprocess-level|-R &lt;level&gt;] [--preprocess-sequence|-r] &lt;e(escape),m(macro),b(both)&gt;
	                    [--abort-on-error|-A] [--pnode|-P &lt;pnode&gt;] [--newline-as-command-separator|-n]
	                    [--allow-double-slash-style-comment|-W]
	                    [--batch-mode|-b] [--verbose|-v] [--trace-level|-T &lt;0,1,2,3&gt;] [--delete-script-on-completion]
	                    [--clear-global-env-on-start-and-exit|-Z]
	                    [--display-summary-on-exit|-Y]
	dump-options    ::= [--exclude-functions|-x] [--literally-as-is|-y] [--dump-script|-d] [--dump-one-line|-o]
	                    [--dump-parameters|-p] [--write|-w &lt;newfile.mse&gt; [--confirm|-c]] | [--append|-a &lt;oldfile.mse&gt;]
	env options     ::= [--global-env|-g | --local-env|-l | --inherited-env|-i | --shared-env|-s] [--env-id|-N &lt;mse id&gt;]
	filter options  ::= [--startup-script|-S &lt;startup script&gt;] [--exit-script|-X &lt;exit script&gt;]
</pre>

<h1>Description</h1>
<p>The command is an interpreter which executes a C-like script in a minishell environment (MSE) that supports preprocessing, flow control, escape sequences, variable substitution, and command substitution. The script supports a mix of bash-like syntax and C-language syntax. The bash-like syntax applies to BALI commands and the C-language syntax applies to flow control.  The command can be aborted at anytime by CTRL-C or the mse-abort command when control is in the context of the mse flow control.</p>
<p>The command can also be run as a filter where the %.__ token represents an output line of the preceding command in the chain.</p>
<p>Note that the task of decoding escape sequences and expanding macros are performed in the context of the mse command. If it is desirable to perform this task in the context of a BALI command, the 'mse-run' command wrapper should be used.</p>
<p>By design, every BALI command returns one of the following status values:</p>
<pre>   10 -- command succeeded
   11 -- command failed due to syntax error
   12 -- command failed
</pre>
<p></p>
<p>It is important to point out that a command wrapper like mse has two types of statuses: the status of the mse command by itself, and the status of each BALI or mse's built-in command executed by mse. Thus, the mse command has to choose what status to return to the shell. In general, the return is chosen as follows:</p>
<pre>   * If the mse command line options have syntax errors, the mse command will return a status of 11.
   * Otherwise, it returns the status of the last BALI or mse's built-in command it executed:
        10 -- BALI or mse's built-in command succeeded
        12 -- BALI or mse's built-in command failed (including syntax error)
</pre>
<p></p>
<p>In other words, if the last BALI or mse's built-in command failed on syntax errors (status = 11), the mse command will convert its status to 12 before returning it to the shell. Note that mse also saves the status of the most recently executed command in predefined variables in the global minishell environment (see Section D7.1).</p>
<p>Certain mse's built-in commands always cause the mse command to exit with a fixed status code. Specifically, 'done' and 'doneall' always return 10, and 'abort' and 'abortall' always return 12 (see Sections D8.7 and D8.8).</p>
<h2>Table of contents</h2>
<pre>              A. Introduction
              A1. Overview
              A1.1. How to specify an mse script?
              A1.2. Variable Name Syntax
              A2. Root, Parent, and Child Commands
              A3. Interpolation Context
              A3.1. Default Interpolation Context
              A3.2. Resolve In Child's Context (RCC)
              A3.3. Resolve In Parent's Context (RPC)
              A4. Minishell Environment
              A5. Global Minishell Environment
              A6. Instantiate A New Minishell Environment
              A6.1. Minishell Environment Config (MSEC)
              A6.2. User-Defined Minishell Environment Variables (MSEV)
              A6.2.1. What is in MSEV?
              A6.2.2. How to create MSEV?
              A6.3. Minishell Library (MSEL)
              A6.3.1. How to define a function?
              A6.3.2. How to call a function?
              A6.3.3. Library database details
              A6.4. Read-Only Built-in Variables
              A6.5. Built-in Minishell Commands
              A6.6. Built-in Minishell Functions With Command-like Syntax
              A6.7. Built-in Math/String Functions With Function-like Syntax
              B. Options
              C. Command Processing Details
              C1. Read a script file from flash
              C2. Load library functions from a library file
              C3. Load a function from a file in flash
              C4. Execution
              C4.1. Phase 1 - Preprocess the mse script file
              C4.1.1. Join lines ending with continuation characters
              C4.1.2. Join lines between #concatenation_begins and #concatenation_ends directives
              C4.1.3. Automatically append command separators
              C4.1.4. Process preprocessor tokens
              C4.2. Phase 2 - Process single statements
              C4.2.1. On-demand preprocessing
              C4.2.2. Complete statement
              C4.3. Special characters
              C4.4. Minishell quoting mechanism
              C5. Process function call
              C6. Process arithmetic assignment
              C7. Process string assignment
              C8. Process BALI commands
              C8.1. MSE directive
              C8.2. MSE built-in function or command
              C8.3. BALI command
              C8.3.1. echo
              C8.3.2. How does mse execute mse, mse-run, strquery, strtoken?
              C8.3.3. Resolve escape sequences and macros
              C8.3.4. Execute BALI command
              C8.3.5. How does mse resolve conflicts of environment options?
              C8.3.6. How does mse execute commands with --eof option?
              C9. Script file name
              C10. Global MSE variables
              C11. Local MSE variables
              C12. Variable Scope
              C13. Variable Substitution
              D. Introduction to Minishell Scripting
              D1. Sample MSE Script
              D2. Observations
              D3. MSE Comments and Script File Preprocessor Directives
              D3.1. Bash-style comments
              D3.2. Double-slash style comments
              D3.3. Trailing comment token directive
              D3.4. The #option directive
              D3.4.1. Handling newlines
              D3.4.2. Handling double slash comments
              D3.5. The #run directive
              D3.6. The #discard_comment_in_continuation_lines directive
              D3.7. The #concatenation_begins and #concatenaton_ends directives
              D4. MSE Assignment Statements
              D4.1. Arithmetic assignment statement
              D4.2. String assignment statement
              D4.2.1. Using string assignment operator ":="
              D4.2.2. Using quoting functions with arithmetic assignment operator "="
              D4.2.3. Using other string expressions with arithmetic assignment operator "="
              D4.3. Command status assignment
              D4.4. Command output assignment
              D4.5. Command output and error assignment
              D5. MSE Flow Control Highlights
              D5.1. Support for conditional
              D5.2. Support for for-loop
              D5.3. Support for foreach-loop
              D5.4. Support for while-loop
              D5.5. Support for do-while
              D5.6. Goto-like directives: break, continue, abort, done, abortall, doneall
              D6. User-Defined Functions
              D7. Built-in Variables
              D7.1. BALI command status
              D7.2. Read-only built-in variables
              D8. Built-in Minishell Commands and Functions
              D8.1. call
              D8.2. Built-in mse::set command to change minishell settings
              D8.3. Built-in mse::echo and mse::echo-n functions
              D8.4. Built-in echo command
              D8.5. BALI, RCC, RPC keywords
              D8.6. Built-in commands to get/set variables:
              D8.7. Built-in abort and done directives
              D8.8. Built-in abortall and doneall directives
              D8.9. Built-in functions print, prints, lprint, lprints
              D8.10. Built-in command mse::execution-summary
              D9. Built-in Math and String Functions
              D10. Functions to query script arguments
              D11. How to specify a literal string in an mse script?
              D11.1. Use double or single quotes
              D11.2. Use quoting functions
              D11.3. Use verbatim escape sequences
              E. Filter
              EXAMPLES
              APPLIES TO
              SEE ALSO
</pre>
<p></p>
<h2>A. Introduction</h2>
<p>This section introduces the concept and terminology necessary to describe the command-line options and features of the mse command.  The details will be discussed in later sections.</p>
<h3>A1. Overview</h3>
<p>The mse command plays the role of the 'sh' command to the bash shell, i.e., its goal is to run a script that supports flow control with the C-like syntax to ease the learning curve. The two characters % and @ are special to mse; they play the role of the dollar sign ($) and backslash (\), respectively, in the bash shell.</p>
<p>The % symbol is called the macro symbol and the @ sign the escape character. How they work is described in the 'macro-support' and 'quoted-text' man pages, respectively. In a nutshell, these characters are always interpreted even if the text containing them is enclosed with single or double quotes. The only exception is when the text is enclosed with a pair of verbatim escape sequences as shown in Table 4 of the 'quoted-text' man page.</p>
<h4>A1.1. How to specify an mse script?</h4>
<p>The following example shows an mse command executing a simple mse script:</p>
<pre>   $ mse 'for (i = 0; i &lt; 10; i = i+1) { echo create file%i; touch file%i; }'
</pre>
<p></p>
<p>We will use this example to show different ways to specify an mse script:</p>
<p>1. The script can be specified directly to the mse command on a single physical line as shown above.</p>
<p>2. The script can be entered interactively below the command line if mse is run with --eof option.</p>
<pre>   $ mse --eof END
   for (i = 0; i &lt; 10; i = i+1) {
     echo create file%i;
     touch file%i;
   }
   END
</pre>
<p></p>
<p>The semicolons at the end of BALI commands or mse statements can be generally omitted in two specific cases:</p>
<p>a) If option --eof is specified with a string ending with a ".scr" suffix:</p>
<pre>   $ mse --eof END.scr
   for (i = 0; i &lt; 10; i = i+1) {
     echo create file%i
     touch file%i
   }
   END.scr
</pre>
<p></p>
<p>b) If option --newline-as-command-separator|-n is specified to mse:</p>
<pre>   $ mse -n --eof END
   for (i = 0; i &lt; 10; i = i+1) {
     echo create file%i
     touch file%i
   }
   END
</pre>
<p></p>
<p>3. The script can be stored in a BALI environment variable.</p>
<pre>   $ env-set --eof END  myscript
   for (i = 0; i &lt; 10; i = i+1) {
     echo create file%i;
     touch file%i;
   }
   END
</pre>
<p></p>
<pre>   $ mse "$myscript"  # BALI shell expands variable in double quoted text.
</pre>
<p></p>
<pre>   Alternatively, we can use mse macro expansion:
</pre>
<p></p>
<pre>   mse %%myscript  # mse expands the token starting with %% during the preprocessing
                   # phase before the execution phase, see section C4.1
   mse %myscript   # or mse expands the token starting with a single % at runtime
                   # when that token begins a statement, see section C4.2.1
</pre>
<p></p>
<p>4. The script can be stored in a minishell environment variable.</p>
<pre>   $ mse-set --eof END  myscript
   for (i = 0; i &lt; 10; i = i+1) {
     echo create file%i;
     touch file%i;
   }
   END
</pre>
<p></p>
<pre>   $ mse %myscript
</pre>
<p></p>
<p>5. The script file can be saved in flash where it can be executed by mse with --file option:</p>
<pre>   $ sscat mytest.mse                # cat file mytest.mse from flash
   for (i = 0; i &lt; 10; i = i+1) {
     echo create file%i;
     touch file%i;
   }
   $ mse --file mytest.mse
</pre>
<p></p>
<p>Note a file can be transferred from a client to flash using the ssput command. Alternatively, it can be created  on the fly using the 'echo' command and the 'sswrdata' filter. For instance,</p>
<pre>   $ echo "for (i = 0; i &lt; 10; i = i+1) {" | sswrdata -f mytest.mse   # create new flash file
   $ echo "  echo create file%i;"  | sswrdata -a mytest.mse           # append to flash file
   $ echo "  touch file%i;" | sswrdata -a mytest.mse
   $ echo "}" | sswrdata -a mytest.mse
</pre>
<p></p>
<p>6. Same as (5) but the script filename can end with a ".scr" extension. In this case, BALI commands and mse statements can be terminated with a newline instead of semicolon:</p>
<pre>   $ sscat mytest.scr
   for (i = 0; i &lt; 10; i = i+1) {
     echo create file%i
     touch file%i
   }
   $ mse --file mytest.scr
</pre>
<p></p>
<p>7. If BALI commands and mse statements are terminated with a newline instead of semicolon, the script can still be saved in a file with a ".mse" extension. However, option --newline-as-command-separator|-n must be specified at runtime:</p>
<pre>   $ sscat mytest.mse
   for (i = 0; i &lt; 10; i = i+1) {
     echo create file%i
     touch file%i
   }
   $ mse -n --file mytest.mse
</pre>
<p></p>
<p>8. To avoid specifying option -n, embed the #option pragma in the script (see Section D4).</p>
<pre>   $ sscat mytest.mse
   #option --newline-as-command-separator
   for (i = 0; i &lt; 10; i = i+1) {
     echo create file%i
     touch file%i
   }
   $ mse --file mytest.mse
</pre>
<p></p>
<h4>A1.2. Variable Name Syntax</h4>
<p>All variables, expressions, assignments, and comparisons are evaluated using the syntax of the &lt;expression&gt; in the 'calculate' command. The variables (e.g. 'i' in the example) are stored in a variable database maintained by the mse command. Variable substitution is indicated by a macro symbol preceding the variable name. The curly brackets are called delimiters. The semicolon is called command or statement separator. The macro symbol, the escape character, the curly brackets, and the semi-colon can be redefined to avoid conflicts if necessary. For simplicity all examples described in this man page assume the default macro symbol (%) and the default escape character (@).</p>
<p>The name of a variable, or more precisely normal variable, is a string of characters that meets two conditions: (i) the first character must be an alphabetic letter or an underscore, and (ii) subsequent characters can be alphanumeric or underscores. Note the BALI shell also enforces the same syntax on all BALI console environment variables.</p>
<p>If a normal variable name is prepended with a period, the entire token is called a built-in or read-only variable because it is predefined by mse and its value cannot be changed by users.</p>
<h3>A2. Root, Parent, and Child Commands</h3>
<p>When an mse command appears in the script executed by another mse command, the former mse is called the child mse command and the latter the parent mse command. The child mse is always executed by the parent mse.</p>
<p>Consider the following example:</p>
<pre>  $ mse 'echo Hello; echo How are you?; echo Nice to see you; echo Bye;'
  Hello
  How are you?
  Nice to see you
  Bye
</pre>
<p></p>
<p>For illustration purposes, this example can be reworked to use two additional mse commands as follows:</p>
<pre>   $ mse 'echo Hello; echo How are you?; mse "echo Nice to see you"; mse "echo Bye"'
</pre>
<p></p>
<p>To simplify the discussion, we will label mse differently as mse1, mse2, etc. This practice will be used for the rest of this man page; to actually run these examples one has to change mse1, mse2, etc back to mse.</p>
<pre>   $ mse1 'echo Hello; echo How are you?; mse2 "echo Nice to see you"; mse3 "echo Bye"'
</pre>
<p></p>
<p>The mse1 command is the parent of mse2 and mse3, mse2 and mse3 are children of mse1.</p>
<p>The leftmost mse command on the command line, which is started by the BALI shell, is called the root mse command. Thus, mse1 is the root mse command in the example above.</p>
<h3>A3. Interpolation Context</h3>
<h3>A3.1. Default Interpolation Context</h3>
<p>Since the introduction of minishell support, a number of BALI commands can resolve macros and escape sequences that appear in their command lines. At the present time the group of interpolation-capable commands consists of</p>
<pre>     mse, mse-run, calculate, strquery,
</pre>
<p></p>
<p>and the built-in 'echo' command if it is executed by an mse command.</p>
<p>By default, whenever control executes a command in this group, the interpolation context is switched to the child command instance. In other words, the execution result appears as if all macros and escape sequences are resolved in the context of the child commands.</p>
<p>By design, macros and escape sequences are resolved for one command at a time, i.e., when the command containing them is executed. To see what command is responsible for resolving them, let's change the last example to use variables:</p>
<pre>   $ mse1 'echo %msg1; echo %msg2; mse2 "echo %msg3"; mse3 "echo %msg4"'
           &lt;-------------------- script -----------------------------&gt;
</pre>
<p></p>
<p>For example, although the entire 'script' above appears as a single argument to mse1, all variables in the script are not resolved at once. Each variable or escape sequence will be resolved when mse executes the command containing it. Thus,</p>
<pre>   - When mse1 executes the first 'echo' command, it will resolve %msg1.
   - When mse1 executes the second 'echo' command, it will resolve %msg2.
   - When mse1 executes mse2, the interpolation context is switched to mse2 because
     mse2 is a minishell-aware command. Hence, mse2 is responsible for resolving macros
     and escapes in the body of its script, namely "echo %msg3".
   - Similarly, when mse1 executes mse3, the interpolation context is switched to mse3.
     Hence, %msg4 will be resolved in the context of mse3.
</pre>
<p></p>
<h3>A3.2. Resolve In Child's Context (RCC)</h3>
<p>By default, if a child command is not an interpolation-capable command, the parent mse command will resolve all tokens in the child's command line before launching the resulting command line in the Bali console.</p>
<p>For example,</p>
<pre>  $ mse 'file := demo.txt; touch %file'
</pre>
<p></p>
<p>What happens is that the parent mse command resolves the child command line "touch %file" into "touch demo.txt", then launches the resulting command line in the Bali console as if the user typed it manually as follows:</p>
<pre>  $ touch demo.txt
</pre>
<p></p>
<p>What if the file variable were defined as "project report"?</p>
<pre>  $ mse 'file :=project report; touch %file'
</pre>
<p></p>
<p>This would result in creating two files named "project" and "report" as follows:</p>
<pre>  $ touch project report
</pre>
<p></p>
<p>The result is fine if the intention is to create two such files. But if the intention is to create a single file named "project report", the %file token must be enclosed in quotes as follows:</p>
<pre>  $ mse 'file :=project report; touch "%file"'
</pre>
<p></p>
<p>Note that the 'touch' command does not see the 5-character string "%file" because the parent mse command already resolved it completely before sending the result to the child command.</p>
<p>If we want the parent mse command to send the 5-character string "%file" as is to the child command and let the child resolve by itself, we need to add "RCC" before the child command name as follows:</p>
<pre>  $ mse 'file :=project report; RCC touch %file'
</pre>
<p></p>
<p>The RCC keyword stands for "Resolve in Child's Context" or "Resolve in Child's Command". It offers an advantage of eliminating quotes. Handling quotes in deeply nested commands is always a challenging task requiring escape sequences. Thus, any method that can reduce quotes is definitely an advantage.</p>
<p>It should be pointed out that the child command is not capable of resolving the macros; the RCC keyword causes the parent mse command to process the child in such a way that the execution outcome appears as if the child command line were resolved by the child itself.</p>
<p>Note that the RCC keyword is consumed by the interpreter before mse sends the command to Bali for execution. The keyword can be specified for every command/filter in a command chain. For example,</p>
<pre>  $ mse "sscat myfile.txt | grep '%token' | wc -l"
</pre>
<p></p>
<p>The grep filter will fail on syntax error if token is "Hoc's book"  because the above line is really as follows:</p>
<pre>  $ mse "sscat myfile.txt | grep 'Hoc's bool' | wc -l"
</pre>
<p></p>
<p>A simple solution is to add the RCC keyword to the command/filter involved:</p>
<pre>  $ mse "sscat myfile.txt | RCC grep '%token' | wc -l"
</pre>
<p></p>
<h3>A3.3. Resolve In Parent's Context (RPC)</h3>
<p>By default, the parent mse command resolves all tokens in a child's command line except when the child is mse, mse-run, calculate, strquery, or echo. To override this default behavior, add "RPC" before the child command name.</p>
<p>For example,</p>
<pre>  $ mse 'msg:=Three spaces   and a dash -; echo %msg'
  Three spaces   and a dash -
  $ mse 'msg:=Three spaces   and a dash -; RPC echo %msg'
  Three spaces and a dash -
</pre>
<p></p>
<h3>A4. Minishell Environment</h3>
<p>The mse command is an implementation of the minishell environment (MSE). In general, the MSE is a layer on top of the BALI console environment to provide support for executing one or more BALI commands in a controlled manner. Its goal is to provide flow control, maintain a list of variables (also known as environment variables), support command preprocessing and escape sequences, perform variable substitution, command substitution, etc. To this end the minishell environment contains a number of objects and tools grouped together into six components as follows:</p>
<pre>  MSE1. Minishell environment configuration (MSEC)
  MSE2. List of user-defined and user-modifiable variable names and values (MSEV)
        This list is known as the minishell environment variables, which
        is different from the list of BALI console environment variables (BSEV).
  MSE3. Minishell environment library (MSEL)
        Collection of user-defined functions.
  MSE4. List of read-only variable names and values
        This list consists of variables that start with a period.
  MSE5. Collection of built-in commands
        See complete list in section D8.
  MSE6. Collection of built-in math and string functions
        See complete list in section D9.
</pre>
<p></p>
<p>A minishell environment may contain one or more objects MSE1 to MSE5. Not all minishell environments contain all six objects. A minishell environment can be global if it is persistent until system shutdown. It can be local if it is destroyed when the running mse command exits.</p>
<h3>A5. Global Minishell Environment</h3>
<p>On start up, the server instantiates one and only one global MSE on each physical node, which persists until system shutdown. By design, the global MSE has only two objects: MSEC (minishell environment config) and MSEV (list of user-defined variables). Initially, the global MSE has only a default configuration (default escape is '@', default macro symbol is '%', etc) and an empty MSEV list.</p>
<p>The global MSEC can be listed or changed by the mse-config command. For instance,</p>
<pre>    $ mse-config
    Environment type : Global Minishell Environment         # MSEC1 setting
    Macro support    : enabled                              # MSEC2
    The following settings are used:
        Escape character       : @                          # MSEC3
        Macro symbol           : %                          # MSEC4
        Ignore macro chaining  : true                       # MSEC5
        Rescanning passes      : 0 times                    # MSEC6
        Fail calculator on undefined variables   : true     # MSEC7
        Fail preprocessor on undefined variables : false    # MSEC8
</pre>
<p></p>
<p>Note the text starting with '#' on each line is not part of the mse-config output; it was manually added to label each setting in the MSEC object for convenient references.</p>
<p>New variables can be added to the global MSEV by the mse-set command; existing variables can be unset by the mse-unset command, or listed by the mse-env command. Only a few other commands can create/read variables in the global MSEV such as 'calculate -m' and 'mse'.</p>
<pre>   Example:
      $ mse-set -v COUNT 4
      COUNT=4
      $ mse-unset COUNT
      $ mse-env --name COUNT
      Undefined variable name: COUNT
</pre>
<p></p>
<p>By convention, the global minishell environment is considered to be the parent environment of all the root mse commands.</p>
<h3>A6. Instantiate A New Minishell Environment</h3>
<p>When a new mse command is started:</p>
<pre>  1. It will obtain a unique integer id called "cid" to differentiate it from other mse instances.
  2. It will build a new minishell environment with all components MSE1 to MSE6 mentioned above.
  3. The "cid" value starts from 1 after system restart. The id can be retrieved by the built-in %.cid macro.
  4. It then proceeds to build all the components as described below.
</pre>
<p></p>
<h4>A6.1. Minishell Environment Config (MSEC)</h4>
<p>MSEC is a configuration component of a minishell environment. It consists of the following two groups of settings (see listing in A5)</p>
<pre>   1. Customizable group:
        MSEC1 - Minishell environment type (GLIS, see A6.2.2)
        MSEC3 - Character defined as escape (default: @)
        MSEC4 - Character defined as macro symbol (default: %)
</pre>
<p></p>
<pre>   2. Common setting group:
        MSEC2 - Flag to support macro token
        MSEC5 - Flag to ignore macro chaining (recursive)
        MSEC6 - Maximum number of rescan passes to resolve a macro
        MSEC7 - Flag to fail calculator on undefined variables
        MSEC8 - Flag to fail preprocessor on undefined variables
</pre>
<p></p>
<p>Each mse command builds its own MSEC object based on the global MSEC object as follows:</p>
<pre>  - cloning the customizable group of the global MSEC object
  - sharing the common setting group of the global MSEC object
</pre>
<p></p>
<p>Thus, the escape character and macro symbol for an mse command can be changed via the following command-line options to mse:</p>
<pre>   mse [--escape-char &lt;escape&gt;] [--macro-symbol &lt;symbol&gt;] ...
</pre>
<p></p>
<p>The only way to change a common setting is to run the mse-config command but the change will affect all mse commands because they share (i.e., use) the same common group.</p>
<h4>A6.2. User-Defined Minishell Environment Variables (MSEV)</h4>
<p>MSEV is a database component of a minishell environment that stores name-value pairs for variables created, or modifiable, by commands in the mse script.</p>
<h4>A6.2.1. What is in MSEV?</h4>
<p>The MSEV database contains:</p>
<pre>   - variables on the left hand sides of assignments; e.g.,
        mse 'x=3; echo %x'
</pre>
<p></p>
<pre>   - variables in the for loops and foreach constructs; e.g.,
        mse 'for(i=0; i &lt; 10; i=i+1) { echo i = %i;}'
        mse 'foreach y (1 3 5 7) { echo y = %y;}'
</pre>
<p></p>
<pre>   - predefined command status variables such as RC, RC_SUCCESS, etc; e.g.,
        mse 'whoami; echo %RC;'
</pre>
<p></p>
<p>Each MSEV database is assigned an integer id, which is system wide unique. By design, this id is the starting address of the database in memory and is known as mse's eid, which can be retrieved by the built-in %.eid macro. The special eid value of zero is reserved to mean the global MSEV.</p>
<h4>A6.2.2. How to create MSEV?</h4>
<p>There are four ways an mse command can build its MSEV database:</p>
<pre>   - simply use the global MSEV
   - create its own MSEV from scratch, which is also known as local MSEV
   - inherit from another existing MSEV (i.e., create a copy of this MSEV)
   - share (i.e., use) with another existing MSEV. This is the default.
</pre>
<p></p>
<p>These four methods of building an MSEV are known as GLIS methods (global/local/inherited/shared). By convention, when an mse command is said to use a global/local/inherited/shared minishell environment, it should be understood that only the MSEV part of the environment is global/local/inherited/shared.</p>
<p>The mse command chooses one and only one method and records it as the environment type in the MSEC1 field of the minishell config object.</p>
<p>Thus, if a number of mse commands have the same MSEV id, they must read from and write to the same list of minishell environment variables. This is the case of global and shared MSEV's.</p>
<p>By default, the root mse command shares the same global MSEV and all instances of 'mse', 'mse-run', 'strquery' in the body of the mse script share the MSEV of the root mse command. For example, all the variables x, i, y in the A6.2.1 examples were written directly to the global MSEV database.</p>
<p>However, the default sharing behavior can be overridden by the following environment-specific options:</p>
<pre>   mse [--global-env|--local-env|--inherited-env|--shared-env] [--env-id &lt;eid&gt;] ...
</pre>
<p></p>
<p>Note that --inherited-env and --shared-env need the id of an existing MSEV for the mse command to inherit from or share with. This id is specified by --env-id. By default, if --env-id is not specified or specified with a zero value, the MSEV is assumed to come from the global minishell.</p>
<p>Every MSEV list has a reference count indicating the number of fibers currently using it. If an MSEV list is not global, the last mse command to use it is responsible for destroying the MSEV list and the corresponding MSEV id becomes invalid or stale. The command will abort if a stale MSEV id is specified.</p>
<h4>A6.3. Minishell Library (MSEL)</h4>
<p>MSEL is a database component of a minishell environment that stores function definitions.</p>
<h4>A6.3.1. How to define a function?</h4>
<p>An mse script can contain one or more function definitions of the form</p>
<pre>    function &lt;function-name&gt; {
       &lt;one or more statements&gt;  # body
    }
</pre>
<p></p>
<p>The &lt;function-name&gt; is a the name of the function, which must conform to the syntax of a variable name. The body can use positional parameters %0 (function name), %1 (first argument), %2, etc. See the next section for more information. Section D6 is devoted exclusively to user-defined functions.</p>
<p>Example:</p>
<pre>    $ sscat greeting.mse
    function greeting {
       echo Hello %1.;
       echo How are you?;
    }
    function bye {
       echo Bye-bye %1;
    }
</pre>
<p></p>
<h4>A6.3.2. How to call a function?</h4>
<p>To invoke a function, call it with the "call" keyword and pass arguments to it as follows:</p>
<pre>   call &lt;function-name&gt; [arg1] [arg2] [arg3] ... [argN];
</pre>
<p></p>
<p>The &lt;function-name&gt; is defined as the zeroth-argument, arg1 is the first argument, etc. All the special tokens in the function body are interpreted as follows:</p>
<pre>       %0 or %.arg0 or %{.argv[0]} is arg0, which is the function name
       %1 or %.arg1 or %{.argv[1]} is arg1
       %2 or %.arg2 or %{.argv[2]} is arg2, etc
       %.argc is the total number of arguments, which is N+1
       %.args is the list of space-delimited arguments starting from arg1
       %.dqargs : same as %.args but each argument is enclosed with doubled quotes
       %.sqargs : same as %.args but each argument is enclosed with single quotes
</pre>
<p></p>
<p>All of these variables are loosely referred to as positional parameters. The variables that start with a period are also known as built-in variables.</p>
<pre>    call &lt;function-name&gt; [arg1] [arg2] ... [argN];
</pre>
<p></p>
<p>Example:</p>
<pre>   $ mse 'function hello { echo Hello;} call hello;'
   Hello
</pre>
<p></p>
<pre>   $ mse 'function hello {echo Hello %1;} call hello Tom;'
   Hello Tom
</pre>
<p></p>
<p>An alternative way is to store all functions in a flash file and load it at runtime. For example, use library file greeting.mse in A6.3.1:</p>
<pre>   $ mse --load-library greeting.mse 'call greeting Tom;'
   Hello Tom.
   How are you?
</pre>
<p></p>
<h4>A6.3.3. Library database details</h4>
<p>Only the root mse command can create a library database in memory and give it a unique library id equal to its mse command id. All the nested commands associated with the root mse command can only use the library created by the root mse command. For this reason, the library is also known as the master database. Each mse command records the library id in the built-in %.libid macro. The library is persistent until the root mse command terminates.</p>
<p>The library database stores a list of name-value pairs:</p>
<pre>  - The name part of the name-value pair is the function name.
  - The value part of the name-value pair is the body of the function.
  - The body is a string that starts from the first left curly bracket after the function
    name and ends with the matching right curly bracket.
</pre>
<p></p>
<p>When an mse command parses an mse script (either defined on the fly or read from a file) and encounters a function definition, it does not execute the function; it simply converts it into a name-value pair and stores it in the master library database.</p>
<p>To see how the minishell framework handles the library database for nested mse commands, let's consider the following example where mse is written as mse1 and mse2 to simplify the explanation and greeting.mse is the file shown in A6.3.1:</p>
<pre>      $ mse1 -L greeting.mse 'call greeting Tom; mse2 "call bye Tom;"'
</pre>
<p></p>
<p>What actually happens is that the minishell framework will fill in the missing information for each nested mse command and then execute them separately as if they were independent:</p>
<pre>      $ mse1 -L greeting.mse 'call greeting Tom;'
      $ mse2 --+ &lt;library-id of mse1&gt; "call bye Tom;"
</pre>
<p></p>
<p>Note that the framework automatically adds the --+library-id option to mse2 because, without it, the stand-alone mse2 command does not know what library database to retrieve the definition of the "bye" function. See section C4.2 and Table 1 for more information.</p>
<h4>A6.4. Read-Only Built-in Variables</h4>
<p>Each minishell environment has a number of built-in variables defined specifically for it. Hence, the values of these variable are generally different for different minishell environments. For a complete list, see section D7.2.</p>
<h4>A6.5. Built-in Minishell Commands</h4>
<p>A built-in minishell command, such as 'call', behaves like a Bali command as far as the syntax is concerned, but can only be run in an mse script. See section D8 for details.</p>
<h4>A6.6. Built-in Minishell Functions With Command-like Syntax</h4>
<p>The mse command supports a number of built-in minishell functions with command-like syntax. The functions can only be invoked in the context of an mse command.</p>
<p>Because the functions are not true commands, their output cannot be piped to another command. In general, its argument list cannot contain tokens "|", "||", and "&amp;&amp;" to connect with another command. See section D8 for details.</p>
<p>However, it is possible to pipe the output of built-in functions to another BALI command by putting them in an mse script and executing it with another mse command. The following example illustrates this technique with the 'print' built-in function:</p>
<pre>    $ sscat test.mse
    mse-set --eof END hello
    print How are you?
    print Is everything going well?
    END
    mse "%hello" | wc -l
    mse-unset hello
</pre>
<p></p>
<pre>    $ mse -f test.mse
    2
</pre>
<p></p>
<h4>A6.7. Built-in Math/String Functions With Function-like Syntax</h4>
<p>All minishell environments support a number of built-in functions with C function syntax. They can be used in an mse script wherever the syntax expects an expression. For example,</p>
<pre>    s := "abcde";
    for (i = 0; i &lt; strlen(s); i = i+1) { # built-in function 'strlen'
       c = char(s,i);   # built-in function 'char'
       echo c = %c;
    }
</pre>
<p></p>
<p>For a complete list of built-in math/string functions, see section D of the 'calculate' man page.</p>
<h2>B. Options</h2>
<dl>
<dt><strong>--escape-char, -e &lt;character&gt;</strong></dt>
<dd><p>Change the escape character to the specified character. This character can be specified as a single ASCII character or a hex character code between 0 and 0xFF. The default is to support escape sequences where the escape character is '@'. This character is chosen to minimize conflicts with Linux shells when the command is run over ssc.</p></dd>
<dd><p>Note that support for escape sequences is disabled if the specified character is '0' (digit 0).</p></dd>
<dt><strong>--macro-symbol, -m &lt;character&gt;</strong></dt>
<dd><p>Change the macro symbol to the specified character. This character can be specified as a single ASCII character or a hex character code between 0 and 0xFF. The default macro symbol is the percent sign (%). All variables preceded by a macro symbol will be resolved even if they are enclosed in single quotes.</p></dd>
<dd><p>Note that support for macro tokens is disabled if the specified character is '0' (digit 0).</p></dd>
<dt><strong>--pipe-token &lt;token&gt;</strong></dt>
<dd><p>Specify the &lt;token&gt; string represents the pipe character '|'. This option causes the mse command to convert each occurrence of &lt;token&gt; in mse statements to '|' while reading the script. In other words, this translation is performed during the preprocessing phase.</p></dd>
<dt><strong>--ampersand-token &lt;token&gt;</strong></dt>
<dd><p>Specify the &lt;token&gt; string represents the ampersand character '&amp;'. This option causes the mse command to convert each occurrence of &lt;token&gt; in mse statements to '&amp;' while reading the script. In other words, this translation is performed during the preprocessing phase.</p></dd>
<dt><strong>--double-quote-token, -Q &lt;token&gt;</strong></dt>
<dd><p>Specify the &lt;token&gt; string represents the double quote character. This option causes the mse command to convert each occurrence of &lt;token&gt; in mse statements to a double quote while reading the script. In other words, this translation is performed during the preprocessing phase.</p></dd>
<dt><strong>--single-quote-token, -q &lt;token&gt;</strong></dt>
<dd><p>Specify the &lt;token&gt; string represents the single quote character. This option causes the mse command to convert each occurrence of &lt;token&gt; in mse statements to a single quote while reading the script. In other words, this translation is performed during the preprocessing phase.</p></dd>
<dt><strong>--preprocess-sequence, -r &lt;instruction&gt;</strong></dt>
<dd><p>By default, the mse command executes individual commands in the script, one command at a time, The execution begins by first resolving escape sequences and macros in each command line in one pass, then executing the resulting command line.</p></dd>
<dd><p>If this option is specified, the preprocessor will transform the entire script before the mse command begins execution as mentioned above. The transformation is based on the specified &lt;instruction&gt;, which is a string consisting of coded characters specifying a sequence of actions to be performed on each pass:</p></dd>
</dl>
<pre>           e : to resolve only escape sequences in one pass
           m : to resolve only macros in one pass
           b : to resolve both escape sequences and macros simultaneously in one pass
           0 : to not resolve, leave it as is
</pre>
<p></p>

<p>The coded letters can be specified multiple times and will be honored in the order of their appearance in the sequence.  For example, '-r em' means scanning the entire script twice: the first pass resolves escape sequences, and the second pass resolves all macros.</p>
<p>--left-delimiter-char, -D &lt;symbol&gt;</p>
<p>Specify a different pair of delimiters to replace the curly brackets. It is sufficient to specify just the left delimiter of the pair.</p>
<p>By default, the curly brackets are used for grouping purposes exactly like in the C language. However, they can be replaced with a pair of square brackets, parentheses, or angle brackets. The square brackets are a good choice because they allow for typing the MSE script directly on a BALI console without requiring quoting.</p>
<p>--command-separator, -C &lt;token&gt;</p>
<p>By default, the semicolon is chosen as a command separator (or terminator) to adhere to the C language syntax. Because the BALI console also interprets the semicolon as a BALI command terminator, all the semicolons that belong to the MSE script must be properly quoted to prevent the BALI shell's interpretation.</p>
<p>To avoid quoting the semicolons, users can specify another token, say "," or ".,", for use as a command terminator. The token can be a single or multiple character string. See the first example in the EXAMPLES section.</p>
<p>--global-env, -g</p>
<p>Specify that the command uses the global MSEV (list of minishell environment variables in the global minishell environment) when creating or modifying variables. However, it still has access to all BALI shell environment variables (BSEV). When the command needs to get the value of a variable, it always searches in the following order: (1) the global MSEV, and (2) the BSEV.</p>
<p>--local-env, -l</p>
<p>Specify that the command creates its own minishell environment from scratch and uses this environment to store its new or modified variables. However, it still has access to all variables in the global minishell environment and the BALI environment. When the command needs to get the value of a variable, it always searches in the following order: (1) its current MSEV (local), (2) the global MSEV, and finally (3) the BSEV.</p>
<p>--inherited-env, -i</p>
<p>Specify that the command creates a copy of an existing minishell environment whose id is specified by --env-id. The command will use this copy to store new and modified variables for its own use. However, it still has access to all BALI shell environment variables (BSEV) When the command needs to get the value of a variable, it always searches in the following order: (1) its current MSEV, (2) the global MSEV, and finally (3) the BSEV.</p>
<p>--shared-env, -s</p>
<p>Specify that the command shares, or uses, an existing minishell environment whose environment id is specified by --env-id. All commands that share this minishell environment will see all changes modified by each other. This option is the default.</p>
<p>--env-id, -V &lt;eid of an existing MSEV&gt;</p>
<p>Advanced option, mainly used by the minishell framework. Recall that the list of minishell variables is assigned an id called eid, which is the address of the list in memory. The eid value can be retrieved by the %.eid macro in the context of the current mse command.</p>
<p>This option is meaningful only when option --inherit-env or --shared-env is specified. It specifies the eid of an existing minishell environment for the current command to share with or inherit from. By default, if --env-id is not specified, the eid value is assumed to be zero. A zero eid value represents the global minishell environment.</p>
<p>--library-id, -I &lt;libid of existing library&gt;</p>
<p>Advanced option, mainly used by the minishell framework. It specifies the library id of an existing library for the current mse command to use. This id can be retrieved by the %.libid macro in the context of the current mse command.</p>
<p>--abort-on-error, -A</p>
<p>In general, if syntax error is encountered (by a BALI command or an MSE statement), the MSE script will fail immediately. But if a BALI command passes syntax check and later fails to execute, control will move on to execute the next statement. If this option is specified, a failed command or statement will cause the MSE script to abort immediately. The effect of this option can be changed dynamically in the MSE script by invoking the built-in command "call abort-on-error [on|off]".</p>
<p>--verbose, -v</p>
<p>Display progress information while parsing and executing statements in the script.</p>
<p>Note that if the script fails and if this option is specified, the command will display the stack trace of the last 10 commands or statements.</p>
<p>--trace-level, -T &lt;level&gt;</p>
<p>Display trace of execution. The higher the trace level, the more verbose the trace.</p>

<pre>          &lt;=0 : do not display traces (default)
            1 : display traces of commands, for/foreach/do/while-loops
            2 : same as (1), plus traces of conditional in if-statement
          &gt;=3 : same as (2), plus traces of initial, conditional, and update in for/while-loop statements
</pre>
<p></p>
<dl>
<dt><strong>--pnode, -P &lt;pnode id&gt;</strong></dt>
<dd><p>For commands that have their standard output/error assigned to a variable (e.g., 'x::=.ls|grep test',  or 'x::=:ls|grep test'), this option specifies which physical node they should be executed on.</p></dd>
<dd><p>A positive value denotes a physical node id in the cluster.</p></dd>
<dd><p>A negative value is a convention for the following: -1 is forwarding the commandline to the physical node hosting the admin vnode, -2 is the physical node hosting the current virtual node.  Any value less than -2 is invalid.</p></dd>
<dd><p>The default value is 0, meaning the entire commandline on the right hand side of the assignment (e.g., 'ls|grep test') is executed in mse's calling context. But if a command in that command line has special needs (e.g., local EVS) on a different physical node, it will be forwarded to the remote node for execution. See section C8.3.4 for details.</p></dd>
<dt><strong>--batch-mode, -b</strong></dt>
<dd><p>By default, commands that do not have their standard output/error assigned to a variable are executed as if the user were typing the command lines manually. Therefore, all command lines are logged in dblog. To avoid this logging, specify --batch-mode.</p></dd>
<dd><p>This option is particularly useful to avoid spamming the dblog when such commands are executed thousands of times, e.g. in a for loop. The option can be turned on/off dynamically with the directive 'mse::set batch-mode true|false|yes|no|1|0'.</p></dd>
<dd><p>An alternative is to prefix each command with the 'nolog' command wrapper, or assign the command output and error messages to a predefined variable named 'devnull' (see section D4.3).</p></dd>
<dt><strong>--dump-script, -d</strong></dt>
<dd><p>Reformat the entire script into multiple lines with appropriate indentation and dump it out. While reformatting, the command also checks each line for simple syntax errors like missing semicolons at the ends of BALI commands and will display WARNING messages accordingly.</p></dd>
<dt><strong>--exclude-functions, -x</strong></dt>
<dd><p>Exclude functions when reformatting and dumping the script. It is meaningful only when specified with -d, -o, -w, or -a.</p></dd>
<dt><strong>--dump-parameters, -p</strong></dt>
<dd><p>Dump all parameters (settings) of the current mse command.</p></dd>
<dt><strong>--dump-one-line, -o</strong></dt>
<dd><p>Reformat the entire script into a single line and dump it out. In addition, save the entire line in a BALI console environment variable called MSE_SCRIPT.</p></dd>
<dt><strong>--preprocess-level, -R &lt;level&gt;</strong></dt>
<dd><p>Control how the preprocessor preprocesses the mse script before dumping it or executing it.</p></dd>
</dl>
<pre>            0 : do not resolve preprocessor tokens
            1 : resolve preprocessor tokens with user-defined variables (default)
            2 : resolve preprocessor tokens with built-in variables
            3 : resolve preprocessor tokens with user-defined or built-in variables
</pre>
<p></p>

<p>User variables are those that start with an alphabetic character or an underscore. Built-in variables are those that start with a dot.</p>
<p>The default depends on how the mse command is run. If the command is to dump/write/append the script, the default is to resolve only preprocessor tokens with user-defined variables (e.g. "%%&lt;name&gt;"). this is because built-in variables (e.g. %%.&lt;name&gt;) usually have their values changed with each running instance of mse. if we dump the script to a file with specific values of built-in variables, the resulting script may no longer work correctly for subsequent runs.</p>
<p>If the mse command actually executes the script, the default is to resolve all preprocessor tokens containing user-defined and built-in variables.</p>
<p>--literally-as-is, -y</p>
<p>Treat the mse script as literal text and dump/write/append it as is, without reformatting the script or adding any additional text or comment.</p>
<p>Option -y cannot be specified with -p and -o. It must be specified together with -d, or -w, or -a. Thus, it is useful to write text data literally as is to a flash file.</p>
<p>When option -y is specified, the filename specified by -w or -a will be used as is, i.e., the command will not add an .mse extension.</p>

<pre>            $ echo -e "Hi Tom!\nHow are you?\n" | mse -c -w myfile.txt -y -R 3 "%%.___"
            $ sscat myfile.txt
            Hi Tom!
            How are you?
</pre>
<p></p>

<p>Note that the preprocess level '-R 3' must be specified in order to resolve the built-in variable token "%%.___" in the mse script. This token represents a raw line (raw means the newline is preserved) from the standard input of the mse filter. If there is no need to resolve anything in the standard input, the sstee or sswrdata filter can be used to produce the same result.</p>

<pre>            $ echo -e "Hi Tom!\nHow are you?\n" | sstee myfile1.txt | devnull
            $ echo -e "Hi Tom!\nHow are you?\n" | sswrdata myfile2.txt
            $ ssdiff myfile.txt myfile1.txt
            Files identical
            $ ssdiff myfile.txt myfile2.txt
            Files identical
</pre>
<p></p>
<p>However, if appending data is needed, only 'sswrdata -a' can provide the same functionality as 'mse -a'. For example,</p>
<pre>            $ echo -e "Hi Tom!\nHow are you?\n" | mse -a myfile.txt -y -R 3 "%%.___"
            $ echo -e "Hi Tom!\nHow are you?\n" | sswrdata -a myfile2.txt
</pre>
<p></p>
<dl>
<dt><strong>--write, -w &lt;newfile.mse&gt;</strong></dt>
<dd><p>Save the script to the specified flash file. Note that the script is saved in a format that allows it to be run again by the "mse -f" command. How the script is saved depends on the three dump options above. If no dump options are specified, the --dump-script option is assumed.</p></dd>
<dd><p>If the file name does not end with an ".mse" extension, it will be appended with one. If the file already exists, the command will prompt for confirmation unless the --confirm option is already specified. If options -d, -p, and -o are specified with --write, the appropriate sections will be written to the file.</p></dd>
<dd><p>It should be pointed out that if both -d and -o are specified at the same time, the single-line version of the script will be commented out. This is to ensure that when the script file is later run by the "mse -f" command, only a single version of the script, namely, the multi-line version, will be executed.</p></dd>
<dt><strong>--confirm, -c</strong></dt>
<dd><p>Suppress the interactive confirmation when using the --write option to write to an existing file.</p></dd>
<dt><strong>--append, -a &lt;file.mse&gt;</strong></dt>
<dd><p>This option works exactly like --write except that the script is appended to the specified flash file. If the file does not exist, it will be created.  Note that --append and --write are mutually exclusive.</p></dd>
<dt><strong>--newline-as-command-separator, -n</strong></dt>
<dd><p>This option is available only when option --file or --load-library-file is specified.</p></dd>
<dd><p>If an mse script is in a file with ".mse" extension, it is expected, by default, that all statements must be terminated with a command separator (default is semicolon). Therefore, it is a syntax error if a statement is terminated with a newline alone. In this case, the script can still be run successfully if it is re-run with this option.</p></dd>
<dd><p>If this option is specified, mse will preprocess the script as follows. It analyzes every line to find out what line is actually missing the command terminator, and then automatically appends a command terminator to that line on behalf of the user. See Section C4.1.3 for details.</p></dd>
<dd><p>Appending a command terminator automatically in this way might result in invalid syntax sometimes. If this happens, one can override the default preprocessing behavior as follows:</p></dd>
</dl>

<p>* If a statement really ends at the newline, terminate it with a command separator explicitly.</p>
<p>* If a statement really extends to the next line, terminate it with a continuation character explicitly (see Section C4.1.1).</p>


<p>By design, if the script filename ends with ".scr" extension, mse will always execute the script as if the --newline-as-command-separator option were also specified. This behavior is intentional to allow mse to execute legacy ssrun scripts without modification. Note that ssrun scripts are usually named with ".scr" extension and usually consist of a sequence of BALI commands listed in separate lines without terminating semicolons.</p>
<p>In summary, this option is meant for quick testing of scripts during development. Final mse scripts should adhere to the syntax described in this man page to ensure they can be parsed and executed correctly. Note that trivial syntax errors like missing semicolons can be found by dry-running the mse command with the --dump-script option.</p>

<pre>       mse --dump-script -n -f myscript.mse
</pre>
<p></p>

<p>The output will show a new version of the script with all the missing semicolons added by mse. This version of the script is what mse would execute if the --dump-script option were removed from the command above.</p>
<p>--startup-script, -S &lt;script to execute on mse startup&gt;</p>
<p>For the mse filter, this option specifies the script that the filter will execute before processing the very first line of the filter's standard input.</p>
<p>For the mse command, this option specifies the script to execute before the first executable mse statement in the mse script. Thus, it will override the "on_running_script" built-in function if it is defined in the mse script. See section D8.11.</p>
<p>--exit-script, -X &lt;script to execute on mse exit&gt;</p>
<p>For the mse filter, this option specifies the script that the filter will execute after it is done with processing all standard input lines.</p>
<p>For the mse command, this option specifies the script to execute after all mse statements in the mse script. Thus, it overrides the "on_exit" built-in function if it is defined in the mse script. See section D8.11.</p>
<p>--load-library-file, -L &lt;library-name.mse&gt;</p>
<p>Load all function definitions in the specified file to the master library database (see Section C2). The file resides in flash.</p>
<p>The library file name must have an ".mse" extension. The base name of the library file is called the library name, which can be used to scope the function. If more library files are needed to load, simply repeat the option as many times as desired. Another way is to use the syntax similar to the --file option below.</p>
<p>Once a function is in the master library database, it can be executed by (i) the --call option specified on the same command line, or (ii) the built-in "call" command in the mse script.</p>
<p>--call [&lt;library-name&gt;::]&lt;function-name&gt; [arg1] [arg2] ... [argN]</p>
<p>Execute the specified function with a number of arguments</p>
<p>The entire name with the &lt;library-name&gt; prefix is called the fully qualified function name. The &lt;library-name&gt; is the filename of the library file that contains the function definition. If the filename has the .mse extension, the extension can be omitted. For example, suppose getaddress() is a function defined in the library file mylib.mse that takes one argument.  To get the address of Tom, run 'mse --call mylib::getaddress Tom'.</p>
<p>The function must have been stored in the master library database. If not, and if the fully qualified function name (FQFN) is specified, mse will identify the file from FQFN and load the function into the master library database. If the function is not found, mse will fail. The FQFN notation should be used to avoid ambiguity when the same function is defined in multiple library files.</p>
<p>Note that mse converts the --call option to an mse script as follows. First, it makes a copy of the function body from the master library database, where the function body can contain positional parameters as listed in section A6.3.2. Second, all positional parameters in this copy are expanded. If the value of a positional parameter does not exist, the macro token will be removed (i.e., replaced with an empty string). Finally, the resulting string, now known as an mse script, replaces all command-line tokens. This script will be executed as described in section C4.</p>

<pre>      --call [&lt;library-name&gt;::]&lt;function-name&gt; [arg1] [arg2] ... [argN]
</pre>
<p></p>

<p>The net effect is as if the fully resolved function body were typed directly on the command line.</p>
<p>For instance, ".myvar" is not a supported built-in variable and hence all occurrences of "%.myvar" will be removed. But "./abc" is not a built-in variable and, hence, "%./abc" will not be expanded. This behavior is consistent with the bash shell where "$&lt;not_variable_name_token&gt;" is preserved as is.</p>
<p>--file, -f &lt;scriptfile1:file2:file3...&gt; [arg1] [arg2] ... [argN]</p>
<p>Execute the specified script file(s) with a number of arguments where the zeroth argument is the script name, i.e., &lt;scriptfile1:file2:file3...&gt;.</p>
<p>All the file names are specified as a single string where the names are separated by a colon. The files are concatenated in the specified order to form a single script.</p>
<p>Note that the zeroth argument is the token after the --file option.</p>
<p>The mse command converts the --file option to an mse script as follows. First, it reads and converts the file(s) into a single string as described in section C1. This string is an mse script, which can contain positional parameters (see section A6.3.2). The mse script will be executed as described in section C4.</p>
<p>--file &lt;scriptfile&gt;::&lt;function-name&gt; [arg1] [arg2] ... [argN]</p>
<p>Execute the specified function in the specified script file. This is an alternative of --call option; i.e., all lines in the file are skipped except those define the specified function. If the file name has an ".mse" extension, the extension can be omitted.</p>
<p>[--] &lt;mse-script&gt;</p>
<p>Specify the mse script to execute. If, for some reason, the script starts with a dash, it should be specified after a double dash argument, which means the end of the option list and the next token after the double dash starts the mse-script. Note that &lt;mse-script&gt; and the two options --file and --call are mutually exclusive.</p>
<p>Observe that the mse command can accept many arguments. The first argument that is not a supported option is considered the start of an mse script. This causes all subsequent arguments to be joined together with a single space in between to form a single string, which is denoted as &lt;mse-script&gt;, and is commonly referred to as mse script.</p>
<p>Thus, the &lt;mse-script&gt; can be a sequence of semicolon-separated statements, each of which can be a BALI command or a script directive. If a semicolon is used to separate mse statements, it should appear in a quoted string to prevent the BALI shell from terminating the mse command prematurely. Note that the semicolon between mse statements can be changed via the -C option.</p>
<p>The &lt;mse-script&gt; can contain function definitions. Because mse is a one-pass interpreter, the mse script cannot contain a function call before the function is defined. The mse script will be executed as described in section C4.</p>
<p>--eof &lt;end-of-file-marker&gt; [arg1] [arg2] ... [argN]</p>
<p>This option supersedes the --script-follows-until|-F option. The option must be specified as the last option in the command line when the command appears in a script. The &lt;end-of-file-marker&gt; argument is treated as the zeroth argument to the script.</p>
<p>The --eof option specifies that the mse command will read the script interactively from the standard input until it sees the &lt;end-of-file-marker&gt; token in a line by itself. As soon as the &lt;end-of-file-marker&gt; string is found to appear in a line by itself, mse will discard this line and the newline preceding it. All the lines that are not discarded form an mse script, which will be preprocessed as described in Section C4.1 and then executed immediately.</p>
<p>By default, all lines in the script must comply with mse syntax (see Example 1 below). In particular, all BALI commands and mse statements must be properly terminated with a command separator (default is semicolon). There are two exceptions:</p>


<p>a) If option  --newline-as-command-separator|-n is specified, BALI commands and mse statements can be terminated with a newline (see Example 2 below).</p>
<p>b) If the &lt;end-of-file-marker&gt; string ends with ".scr" suffix, treat the mse script as if it came from a file with ".scr" extension; i.e., BALI commands and mse statements can be terminated with a newline.</p>


<p>The following three examples are equivalent:</p>

<pre>             Example 1       |      Example 2            |     Example 3
        Strict mse syntax    |  Use -n to omit ";"       | Use suffix ".scr" to omit ";"
        ---------------------|---------------------------|------------------------------
        $ mse --eof END      |  $ mse -n --eof END       | $ mse --eof END.scr
        echo;                |  echo                     | echo
        echo Hello;          |  echo Hello               | echo Hello
        echo How are you?;   |  echo How are you?        | echo How are you?
        END                  |  END.scr                  | END.scr
                             |                           |
        Hello                |  Hello                    | Hello
        How are you?         |  How are you?             | How are you?
</pre>
<p></p>

<p>Note that there are two lines containing the end-of-file markers if the mse command line is also counted. By default, all the statements listed between the two end-of-file markers must be terminated appropriately with a semicolon. But if option -n is specified to mse, the command will automatically add semicolons to statements when it deems necessary.</p>
<p>Finally, note that if mse is used in an mse script, the --eof option has different behavior depending on how the option name is specified (see Section C8.3.6 below for explanation and examples). For simplicity, the mse command that runs the mse script is referred to as the parent mse command, and the mse command that appears in the mse script is the child mse command.</p>
<p>If the full spelling "--eof" is specified, the option will be processed in the context of the parent mse command, and hence, all the data must be specified below the child mse command line.</p>
<p>If the partial spelling "--eo" is specified, the option will be processed in the context of the child mse command. Thus, the user has to enter the data interactively every time the mse script is run.</p>
<p>--delete-script-on-completion</p>
<p>Specify that the script file from flash should be deleted after the mse command runs to completion. The operation is advisory; the mse command does not fail if delete fails. This is supported whenever the mse script is specified by --file option.</p>
<p>This option is useful for internal testing where test files should be cleaned up after testing.</p>
<p>--display-summary-on-exit, -Y</p>
<p>Display statistics on commands and unit tests that succeeded, failed, or failed due to syntax. This summary can also be obtained by executing a built-in command "mse::execution-summary" at the end of the mse script. Note that this flag can be changed dynamically by the built-in mse::set display-summary-on-exit command.</p>
<p>--clear-global-env-on-start-and-exit, -Z</p>
<p>Specify that the interpreter has to clear the global minishell environment both on startup and on exit. In cases where the command fails to parse the command line options, it will have to reparse the option to look for just this option and the --display-summary-on-exit|-Y and so that it can handle the unit testing summary correctly.</p>
<p>--allow-double-slash-style-comment</p>
<p>Specify that the mse script can have C++ style of comments that begin with a double slash. See Section D3 for more information.</p>

<h2>C. Command Processing Details</h2>
<h3>C1. Read a script file from flash</h3>
<p>The goal is to convert the script file into an mse script string.</p>
<p>The initial mse script string is empty when mse opens the file from flash and reads line by line. If a newline is escaped by an escape character, the escape character and the newline are discarded, effectively joining the next line to the current line. The resulting line is processed for comments and pragmas (preprocessor directives). After the comments and pragmas are processed and discarded, the remaining text consists of mse statements. All mse statements are joined together to form a single string called the mse script. The details are as follows:</p>
<p>First, the mse command removes all leading and trailing blanks from a line. It discards the resulting line if it is empty or a comment line (see section D3). It also discards any trailing comments on the line.</p>
<p>At this point, the line can be either a preprocessor directive (e.g., #ifdef, #endif, #define, #include, etc) or an mse statement. If a preprocessor directive, it will be handled in the same way as a C preprocessor would. If an mse statement, it will be appended to the mse script string.</p>
<p>The final string is an mse script that can contain mse statements as well as function definitions in the order of their appearances in the file.</p>
<h3>C2. Load library functions from a library file</h3>
<p>The goal is to find out all function definitions in the file and store them in the master library database.</p>
<p>The first step is to read the file and process all parser directives as described in section C1. The next step is to look for lines that begin with the "function" keyword.</p>
<p>If a line begins with the "function" keyword, the mse command will read more lines if necessary to fully identify the function body. The entire function definition will be converted to a name-value pair to store in the master library database, where the name is the function name and the value is the function body.</p>
<h3>C3. Load a function from a file in flash</h3>
<p>The first step is to read the file as described in C1. Then discard all lines except those that contain the definition of the function of interest. The result is a single mse script string. Note that the mse command does not attempt to add any function definition to the master library database.</p>
<h3>C4. Execution</h3>
<p>After validating all the command line options successfully and loading all the files, if any, successfully, the command will execute the mse script in two phases.</p>
<p>It is important to note that there are two preprocessors involved. The first one is the script file preprocessor, which works on script files and understands all pragmas starting with the # character like "#define", "ifdef", "#endif", "#option", etc as described in section D3. Once all the files are loaded and preprocessed successfully, the mse command invokes another preprocessor to preprocess the entire mse script. This preprocessor does not understand pragmas; it understands only preprocessor token as described below.</p>
<h4>C4.1. Phase 1 - Preprocess the mse script file</h4>
<p>This phase is mostly similar to the C preprocessor processing a C file by processing all pragmas (tokens starting with #) and expanding all macros that are defined by #define.</p>
<p>However, the mse command does more than the C preprocessor. Specifically, it performs two passes as follows.</p>
<dl>
<dt><strong>Preprocessing pass 1</strong></dt>
<dd><p>1. Scan file, line by line.</p></dd>
<dd><p>2. Join lines that end with continuation characters</p></dd>
<dd><p>3. Smartly append a missing command separator to the end of line if mse is run with option --newline-as-command-separator</p></dd>
<dd><p>4. Interpret all pragmas (tokens starting with #)</p></dd>
<dd><p>5. This pass results in an mse script free of pragmas.</p></dd>
<dt><strong>Preprocessing pass 2</strong></dt>
<dd><p>1. Rescan the new mse script, line by line.</p></dd>
<dd><p>2. Expand all preprocessor tokens (tokens starting with %%).</p></dd>
<dd><p>3. This pass results in an mse script free of preprocessor tokens.</p></dd>
</dl>
<h4>C4.1.1. Join lines ending with continuation characters</h4>
<p>The escape character (default is '@') also plays the role of a continuation character it it appears immediately before a newline character.</p>
<p>If a physical line ends with a continuation character, the continuation character and the following newline are removed, and the resulting line is said to continue on the physical line immediately below it. The continuation process repeats until mse encounters the first physical line without a continuation character.</p>
<p>However, there is a caveat if the concatenation line is a comment line. In this case, if the comment line also ends with a continuation character, the continuation process will continue on the next line but the comment itself is discarded before concatenation.  This behavior is different from the Bash shell where the first comment line always terminates the continuation process.</p>
<p>Note: In release 13.6.6913 or earlier, the continuation process does not distinguish comment and non-comment lines; i.e., mse does not discard the comment line when it performs concatenation.</p>
<p>Example: The following three scripts are equivalent and produce the same output</p>
<pre>     $ sscat test1.scr
     echo abc def
</pre>
<p></p>
<pre>     $ sscat test2.scr   # 2 physical lines form a single logical line
     echo abc @
     def
</pre>
<p></p>
<pre>     $ sscat test3.scr   # 6 physical lines form a single logical line
     echo abc @
     # comment is ignored @
         # this entire physical line, including leading spaces, is ignored @
     #@
     @
     def
</pre>
<p></p>
<p>Note that the mse script can switch back and forth between the new and old behaviors by using the directive '#discard_comment_in_continuation_lines yes' (see subsection D3.6).</p>
<h4>C4.1.2. Join lines between #concatenation_begins and #concatenation_ends directives</h4>
<p>The following two directives enable the concatenation mode for all lines in between:</p>
<pre>     #concatenation_begins
     &lt;line 1&gt;
     &lt;line 2&gt;
     . . . . .
     &lt;line n&gt;
     #concatenation_ends
</pre>
<p></p>
<p>All lines between the two directives are preprocessed normally for directives, escape sequences, quoted text, and comments. The results are then concatenated together to form a single line.</p>
<p>Thus, the concatenation mode is an alternative method of joining lines without using the continuation character.</p>
<h4>C4.1.3. Automatically append command separators</h4>
<p>All statements in an mse script should be terminated with a command separator (default is ";"). It is possible to omit the command separators if each statement is completely written in a separate line. In this case, one has to run the mse command with --newline-as-command-separator option so that, during the preprocessing phase, mse can analyze the script for missing command separators and adding them back automatically.</p>
<p>Note that appending a command separator indiscriminately to every line that does not end with a command separator can result in errors as illustrated in the following example.</p>
<pre>       # Original script (correct)   |    # Modified script by adding missing ";" blindly
       for (i=0; i &lt; 20; i=i+1)      |    for (i=0; i &lt; 20; i=i+1);   # error
       {                             |    {;                          # acceptable
          if                         |       if;                      # error
             (%i &gt; 5 &amp;&amp;              |          (%i &gt; 5 &amp;&amp;;           # error
              %i &lt; 10)               |           %i &lt; 10);            # error
             echo i = %i             |          echo i = %i;          # only this one is correct
       }                             |    };                          # acceptable
</pre>
<p></p>
<p>Thus, the mse interpreter will perform some preliminary validation of syntax before deciding to append the missing command separators. The algorithm is complex but the rules can be summarized as follows:</p>
<pre>    1. Do not append a command separator to (see the erroneous example above):
       a. Lines already terminated with a command separator (obvious).
       b. Lines already terminated with a continuation character.
          This line is subject to preprocessing described in Section C4.1.1.
       c. Lines containing just one key word: if, else, for, foreach, do, while, function.
       d. Lines containing just two words: else if, function &lt;name&gt;.
       e. Lines ending with any of these 10 characters: { } [ ] ( ) &lt; &gt; &amp; |
          However, this rule is overridden by (2) below.
</pre>
<p></p>
<pre>    2. Always append a command separator if missing:
       a. Lines starting with the 'echo' command; e.g., echo x[15]
       b. Lines starting with well-known Linux command name; e.g., ls file.txt[7]
       c. Lines that are arithmetic assignments; e.g., x = 3*(a + 4)
       d. Lines that are string assignments; e.g., s :=Tom (20 years old)
</pre>
<p></p>
<pre>    3. Cases not listed in (1) and (2)
       Most of the times, append a command separator to a simple statement if missing.
       If this turns out to be wrong, one can always override mse by specifying
       exactly one's intention, with either a command separator (see rule 1a),
       or a continuation character (see rule 1b).
</pre>
<p></p>
<h4>C4.1.4. Process preprocessor tokens</h4>
<p>A preprocessor token, or preprocessor macro, is a token that begins with two consecutive macro symbols of the forms:</p>
<pre>         &lt;macro-symbol&gt;&lt;macro-symbol&gt;&lt;variable-name&gt;
         &lt;macro-symbol&gt;&lt;macro-symbol&gt;&lt;escape-sequence&gt;
</pre>
<p></p>
<p>The default macro symbol is '%' and the default escape character is '@'. Thus, the preprocessor tokens appear as follows:</p>
<pre>         %%&lt;variable-name&gt;       e.g.  %%message
         %%&lt;escape-sequence&gt;     e.g., %%@P
</pre>
<p></p>
<p>During phase 1, the command walks the entire script, joining lines if possible, processing all pragmas, and then resolving all preprocessor tokens based on the preprocess level specified by the --preprocess-level option.</p>
<p>a) Resolve %%&lt;variable-name&gt;</p>
<p>If a variable that must be resolved is not defined, the entire preprocessor token will be removed from the script. This behavior is controlled by a setting in the minishell config (run mse-config and check the value of 'Fail preprocessor on undefined variables') and can be changed by the mse-config command.</p>
<p>If the value of the variable is defined, the entire token "%%&lt;variable-name&gt;" will be replaced with the value.</p>
<p>Note the values of the variables are arbitrary, i.e., can be syntactically incorrect. The goal of this pass is to allow users to use environment variables to write a long script. This is similar to writing a C program using macros defined by #define.</p>
<p>b) Resolve %%&lt;escape-sequence&gt;</p>
<p>If the specified escape-sequence is defined (see the 'quote-text' man page), the entire token "%%&lt;escape-sequence&gt;" will be replaced with the value that the sequence represents. For example, "%%@P" will be replaced with "|" and "%%@A" with "&amp;".</p>
<p>c) Resolve %%(run) token</p>
<p>The %%(run) preprocessor token is followed by a command line. Its syntax is as follows:</p>
<pre>      %%(run) &lt;command line&gt;;
</pre>
<p></p>
<p>Whenever the preprocessor encounters this syntax, it will handle as follows:</p>
<pre>   - resolve escapes and macros in &lt;command line&gt;,
   - execute it,
   - remove the entire original line (i.e., "%%(run) &lt;command line&gt;;") from the mse script.
</pre>
<p></p>
<p>Therefore, this command will never be executed again in the execution phase.</p>
<p>Example: The following three scripts are equivalent:</p>
<pre>     $ sscat test1.scr
     if (3 != 4) echo abc
     echo done
</pre>
<p></p>
<pre>     $ sscat test2.scr
     #run mse-set  A   'if (3'
     #run mse-set  B   '!= 4) echo abc'
     %%A %%B
     #run mse-unset  A
     #run mse-unset  B
     echo done
</pre>
<p></p>
<pre>     $ sscat test3.scr
     %%(run) mse-set  A   'if (3'
     %%(run) mse-set  B   '!= 4) echo abc'
     %%A %%B
     %%(run) mse-unset  A
     %%(run) mse-unset  B
     echo done
</pre>
<p></p>
<p>Note that when mse runs test2.scr, what we have after the first pass of the preprocessing phase is a script that is identical to test3.scr. Therefore, the two scripts test2.scr and test3.scr are identical after the first pass of the preprocessing phase.</p>
<p>d) Change preprocess level</p>
<p>The initial value of the preprocess level can be changed by the --preprocess-level option to the mse command. It can be changed dynamically as the preprocessor scans the script via the following directives:</p>
<dl>
<dt><strong>%%(suspend)</strong></dt>
<dd><p>When the preprocessor encounters this token, it will change its preprocess level to zero. This level effectively makes the preprocessor ignore all subsequent %% tokens except %%(suspend) and %%(resume).</p></dd>
<dt><strong>%%(resume)</strong></dt>
<dd><p>When the preprocessor encounters this token, it will restore its preprocess level to the value before suspension.</p></dd>
<dt><strong>%%(level=n)</strong></dt>
<dd><p>This changes the preprocess level to n where n = 0, 1, 2, and 3.</p></dd>
</dl>
<p>Example,</p>
<pre>     $ sscat preprocessor.scr
     mse-set  A   'if (3'
     mse-set  B   '!= 4) echo abc'
     mse '%%A %%B'
</pre>
<p></p>
<p>a) When running the script with ssrun:</p>
<pre>     $ mse-env | mse-unset        # delete all global minishell variables
     $ ssrun -x preprocessor.scr
     abc
</pre>
<p></p>
<p>The result is correct because it is the mse command running '%%A %%B' that resolves its argument. After the precessing phase  the mse command will see the following script:</p>
<pre>     mse 'if (3 != 4) echo abc'
</pre>
<p></p>
<p>b) When running the script with mse, the result is incorrect:</p>
<pre>     $ mse-unset --all
     $ mse -f preprocessor.scr
                                    &lt;&lt;&lt;&lt; nothing
</pre>
<p></p>
<p>To see what happens, turn on --verbose:</p>
<pre>     $ mse-unset --all
     $ mse -v -f preprocessor.scr
     [mse #9] Run mse using library id 9
   	[mse-set  A   'if (3';mse-set  B   '!= 4) echo abc';mse '%%A %%B';]
      [mse #9] Phase 1: preprocessed:
   	[mse-set  A   'if (3';mse-set  B   '!= 4) echo abc';mse ' ';]
      [mse #9] Phase 2: start processing individual statements/commands...
        [mse #9] Phase 2: Process: mse-set  A   'if (3'
        [mse #9] Phase 2: Process: mse-set  B   '!= 4) echo abc'
        [mse #9] Phase 2: Process: mse ' '                                   &lt;&lt;&lt;&lt; wrong result
     [mse #9] Exit mse: status = 10
</pre>
<p></p>
<p>(Note "[mse #9]" means the mse instance with id 9. The mse framework hands out a unique id to each instance of mse, mse-run, strquery, or any mse-aware command that uses the mse library. The id starts from 1 on system reboot.)</p>
<p>Thus, the result is wrong because the %% tokens are resolved in the context of the first 'mse' command, which runs '-f preprocessor.scr'. When this mse preprocesses the script, the variables A and B have not been defined yet.</p>
<p>But if we run the command again, everything is fine because A and B were already defined in the first run:</p>
<pre>     $ mse -f preprocessor.scr
     abc
</pre>
<p></p>
<p>To solve this issue, we have to let the second mse (i.e., mse in the script) resolve the %% tokens. There are two ways to accomplish this:</p>
<pre>    1. Disable the preprocessor of the first mse command:
</pre>
<p></p>
<pre>         $ mse-unset --all
         $ mse -R 0 -f preprocessor.scr
         abc
</pre>
<p></p>
<pre>    2. Or use suspend and resume directives:
</pre>
<p></p>
<pre>         $ sscat preprocessor1.scr
         mse-set  A   'if (3'
         mse-set  B   '!= 4) echo abc'
         %%(suspend)
         mse '%%A %%B'
         %%(resume)
</pre>
<p></p>
<pre>         $ mse-unset --all
         $ mse -f preprocessor1.scr
         abc
</pre>
<p></p>
<h4>C4.2. Phase 2 - Process single statements</h4>
<p>In this phase the mse command parses the script string from left to right, token by token, to identify statement boundaries, one at a time. (Token parsing will be described in sections C4.3 and C4.4 in detail.) To this end, mse relies on the leading token of a statement to determine where the statement ends.</p>
<p>a) If the first token is one of the reserved keywords:</p>
<pre>    for, while, do, if, foreach, function
</pre>
<p></p>
<p>then mse locates the end of the statement based on the following syntax:</p>
<pre>        - for (...; ...; ...) { ...... }
        - while (...) { ...... }
        - do { ...... } while (...);
        - if (...) {...} [ else if (...) {...} ] [else {...}]
        - foreach &lt;variable&gt; (...) {...}
        - function &lt;function_name&gt; {...}
</pre>
<p></p>
<p>b) If the first token is not one of those reserved keywords, mse considers the next semicolon (or next closed curly bracket, or end of script, whichever occurs first) as the end of the statement. The statement can be a BALI command, an mse built-in command or mse directive, or an mse assignment statement.</p>
<p>Thus, if the first token of a statement contains macros, mse cannot proceed to find the statement end. To solve this dilemma, mse supports on-demand preprocessing.</p>
<h4>C4.2.1. On-demand preprocessing</h4>
<p>If the first token of a statement contains macros, mse will resolve all macros and escape sequences in the entire statement as if it were still in the preprocessing phase. The resulting text string will then be subject to phase 2 processing. For this phase to succeed, the new text string must be syntactically correct.</p>
<p>Example:</p>
<pre>   $ mse 'x=1; %abc hello;'
</pre>
<p></p>
<p>If the value of 'abc' is 'if (%x) echo', then</p>
<pre>   * Phase 1: Because there is nothing to preprocess, the original script is unchanged:
       'x=1; %abc hello'
</pre>
<p></p>
<pre>   * Phase 2:
       - execute the first statement: 'x=1;'
       - execute the second statement: '%abc hello;'
         Because the first token is a macro, it needs to be resolved.
         Thus, mse will perform on-demand preprocessing and get:
                 if (%x) echo hello
         Then, mse will perform phase 2 preprocessing on the resulting text:
             - first, resolve all macros and escape sequences:
                     if (1) echo hello
             - then, execute to produce:
                     hello
</pre>
<p></p>
<h4>C4.2.2. Complete statement</h4>
<p>A complete statement can be a function definition, a compound or simple statement. A simple statement can contain a single command or multiple commands.</p>
<p>The following script example introduces some concepts that help explain the MSE engine parser:</p>
<pre>  $ sscat example.mse
  echo Hello;
  for (i = 0; i &lt; 5; i = i+1) {
    echo file%i.txt;
    if (%i .mod. 2 == 1) {
      sscat file%i.txt | strquery --has foo;
    } else {
      wc -l file%i.txt;
    }
  }
  echo Bye;
</pre>
<p></p>
<p>This script consists of 3 complete statements:</p>
<pre>  - Complete statement #1 begins with 'echo' and ends with the first semicolon:
       echo Hello;
  - Complete statement #2 begins with 'for' and ends with the matching curly bracket:
       for (i = 0; i &lt; 5; i = i+1) {
         echo file%i.txt;
         sscat file%i.txt | strquery --has foo;
         if (%i .mod. 2 == 1) {
           ls -l file%i.txt
         } else {
           wc -l file%i.txt;
         }
       }
  - Complete statement #1 begins with 'echo' and ends with the following semicolon:
       echo Bye;
</pre>
<p></p>
<p>Complete statement #1 is a simple statement. A simple statement usually begins with a BALI command name.</p>
<p>Complete statement #2 is a compound statement. A compound statement usually begins with a reserved MSE directive such as "if", "for", "foreach", "while", "do", "function", etc. This complete statement, in turn, has 3 statements:</p>
<pre>  - Statement #1 is a simple statement: echo file%i.txt;
  - Statement #2 is a simple statement: sscat file%i.txt | strquery --has foo;
  - Statement #3 is again a compound statement:
         if (%i .mod. 2 == 1) {
           ls -l file%i.txt;
         } else {
           wc -l file%i.txt;
         }
    This statement has two simple commands:
       - simple command #1: ls -l file%i.txt;
       - simple command #2: wc -l file%i.txt;
</pre>
<p></p>
<p>In general, a simple statement usually begins with a BALI command name or some MSE keyword that precedes a BALI command name (e.g. "call"). A simple statement can be a simple command like</p>
<pre>      echo file%i;
</pre>
<p></p>
<p>It can also be a compound command that contains multiple simple commands connected with "&amp;&amp;", "||", or "|" such as:</p>
<pre>      sscat file%i.txt | strquery --has foo;
</pre>
<p></p>
<p>Thus, if the first token of a statement contains macros, mse cannot proceed to find the statement end. To solve this dilemma, mse supports on-demand preprocessing, which works as follows.</p>
<p>If the first token of a statement contains macros, mse will resolve all macros and escape sequences in the entire statement as if it were still in the preprocessing phase. The resulting text string will then be subject to phase 2 processing. For this phase to succeed, the new text string must be syntactically correct.</p>
<p>Note that if a statement is a function definition, it will be stored in the master library database. Otherwise, the mse command treats the complete statement as a new mse script and parses it recursively until it sees the first simple statement.</p>
<p>Simple statements will then be processed as described in subsections C5 to C8.</p>
<h4>C4.3. Special characters</h4>
<p>The mse interpreter has 10 special characters:</p>
<pre>    * 8 word token delimiters "{}|; \t()" (compared to seven in BALI: "{}|&amp;; \t").
    * one escape character, default is '@'.
    * one macro symbol, default is '%'.
</pre>
<p></p>
<pre>    Example:
</pre>
<p></p>
<pre>     for (i=0; i&lt;10; i=i+1) {
        x = i*i;
        if (i &gt; 3) {
           x = x + 10;
        }
        echo x[%i] = %x;
     }
</pre>
<p></p>
<p>1) The {} characters are the statement grouping delimiters. Their functionalities are exactly like in the C programming language:</p>
<p>2) The semicolon is the default delimiter for mse statements or BALI commands.</p>
<p>3) The () characters are used to group arithmetic expressions or conditionals.</p>
<p>4) Note that the '&amp;' character is literal in mse.</p>
<p>5) The &amp;&amp; token is special to BALI but literal in mse. If an mse command line contains &amp;&amp;, mse will send the entire command line to BALI for execution because it does not recognize &amp;&amp; as special. It is then up to BALI to handle the &amp;&amp; token correctly.</p>
<p>6) Note all the characters "{};@%" can be redefined by specifying an appropriate option to the mse command.</p>
<h4>C4.4. Minishell quoting mechanism</h4>
<p>Quoting is a mechanism to remove the special meaning of minishell special characters that are listed in section C4.3. The mse interpreters supports five types of quoting: escape character, macro symbol, matched single quotes, matched double quotes, quoting functions.</p>
<dl>
<dt><strong>Escape character</strong></dt>
<dd><p>If the escape character precedes another character, it forms an escape sequence that is to be interpreted as described in the quoted-text man page. In particular, if the escape character precedes a special character in section C4.3, it makes that character losing the special meaning and becoming a normal character.</p></dd>
<dt><strong>Macro symbol</strong></dt>
<dd><p>If the macro symbol is followed by an opening delimiter {, (, [, or &lt;, then all the characters enclosed between the opening delimiter and the first subsequent matching closing delimiter preserve their literal meaning except escape characters and macro symbols.</p></dd>
<dd><p>For example, the mse statement [rm %(echo file1 file2 file3)] consists of two tokens: [rm], and [%(echo file1 file2 file3)], where the square brackets are used to delimit the text for illustration purposes. The second token is recognized as a command substitution. Once this token is expanded, the original mse statement becomes [rm file1 file2 file3]. When mse sends this command to BALI for execution, the rm command will delete 3 files because it sees 3 arguments: [file1], [file2], and [file3].</p></dd>
<dd><p>Note that the mse statement [rm "%(echo my report)"] has a different behavior. Because of the double quotes, the rm command will delete one file only, namely, "my report".</p></dd>
<dt><strong>Single Quotes</strong></dt>
<dd><p>Enclosing characters in single quotes preserves the literal meaning of all the characters except single quotes, escape characters, and macro symbols.</p></dd>
<dt><strong>Double Quotes</strong></dt>
<dd><p>Enclosing characters in double quotes preserves the literal meaning of all the characters except double quotes, escape characters, and macro symbols.</p></dd>
<dt><strong>Quoting function str()</strong></dt>
<dd><p>When the minishell interpreter encounters an unquoted str(...) string in an mse script, it will treat the entire string starting from "str" to the closing parenthesis as a single token regardless of whatever is inside the parentheses. All the characters in the argument preserve their literal meaning except escape characters and macro symbols. Thus, the purpose of the function is to provide a pair of invisible quotes to the string inside the parentheses.</p></dd>
<dd><p>The str function causes the minishell to replace the entire occurrence of str(...) with a string value which is equal to the function argument.</p></dd>
<dd><p>Note that the parentheses enclosing the function argument can be replaced with any of these delimiters: &lt;&gt;, [], or {}, or by a pair of strings each of which is of the form "/some_string/".</p></dd>
<dd><p>For example, all the occurrences below in an mse script will be replaced with the same string value [ Hoc's book ], where the square brackets are not part of the result. This convention is used throughout examples in section C4.4.</p></dd>
</dl>
<pre>           str( Hoc's book )
           str{ Hoc's book }
           str[ Hoc's book ]
           str&lt; Hoc's book &gt;
           str/abc/ Hoc's book /abc/
</pre>
<p></p>
<dl>
<dt><strong>Quoting function qstr()</strong></dt>
<dd><p>If str('...') is desired, it can be replaced with qstr(...) to eliminate the single quotes. Thus, qstr() has the same syntax as described in str(). The q prefix means single quoted.</p></dd>
<dd><p>The qstr function causes the minishell to replace the entire occurrence of qstr(...) with a string value which consists of a single quote followed by the function argument, which is followed by another single quote. For example, qstr(Hoc's book) will be replaced with ['Hoc's book'], where all the three single quotes are part of the text.</p></dd>
<dt><strong>Quoting function dqstr()</strong></dt>
<dd><p>If str("...") is desired, it can be replaced with dqstr(...) to eliminate the double quotes. Thus, dqstr() has the same syntax as described in str(). The dq prefix means double quoted.</p></dd>
<dd><p>The dqstr function causes the minishell to replace the entire occurrence of dqstr(...) with a string value which consists of a double quote followed by the function argument, which is followed by another double quote. For example, dqstr(Hoc's book) will be replaced with ["Hoc's book"], where the two double quotes and the single quote are part of the text.</p></dd>
<dt><strong>Math-specific quoting functions mstr(), mqstr(), mdqstr()</strong></dt>
<dd><p>These functions have essentially the same functionalities as those without the m prefix.</p></dd>
<dd><p>When the minishell interpreter encounters these functions in unquoted text in an mse script, it will treat the entire string starting from the function name to the closing parenthesis as a single token. However, the interpreter does not attempt to replace their occurrences in the script with the values that these functions would return.</p></dd>
<dd><p>These functions are understood by the calculator library, which processes mathematical expressions in an mse script, evaluates expressions to the 'calculate' command, or --calc option to strquery filter, etc. When the calculator engine processes literal strings, it needs to see the strings enclosed by a pair of double/single quotes. But these quotes may not survive when the strings arrive at the command after processed by the BALI shell, then minishell. Thus, using an appropriate function mstr, mqstr, mdqstr will help the strings pass the BALI shell and minishell in a safe manner.</p></dd>
<dt><strong>Quoting function esc()</strong></dt>
<dd><p>This function has the same syntax as str(). All the characters in the function argument preserve their literal meaning except macro symbols. The function returns a string value which results from (i) defining a private escape character equal to 0x01, (ii) prepending the function argument with one private escape character, and (iii) evaluating the resulting string. For example, esc(Ax41;) returns [&amp;x41;]</p></dd>
</dl>
<p>The following examples use the square brackets to delimit the text; they are not part of the text.</p>
<pre>    Bali:
      $ ls "abc def"      # Bali delivers to ls 1 token: [abc def]
      $ ls str(abc def)   # Bali delivers to ls 2 tokens: [str(abc], [def)]
</pre>
<p></p>
<pre>    mse script:
      ls "abc def"        # mse delivers to ls 1 token: [abc def]
      ls str(abc def)     # mse delivers to ls 1 token: [abc def]
      ls str(abc'";def)   # mse delivers to ls 1 token: [abc'";def]
</pre>
<p></p>
<p>Thus, mse provides str() as another pair of double (or single) quotes to quote a string.</p>
<h4>C5. Process function call</h4>
<p>If a simple statement is a function call of the form</p>
<pre>     call &lt;function-name&gt; [arguments...]
</pre>
<p></p>
<p>the mse command will not try to resolve all escape sequences and variables in the call. Rather, it will launch a child mse command with the following syntax:</p>
<pre>    mse +e @ +m % +s +V &lt;env-id&gt; +P &lt;pnode&gt; +I &lt;library-id&gt; --call &lt;function-name&gt; [arguments...]
</pre>
<p></p>
<p>It is this child mse command that will resolve all macros and escape sequences in all the arguments before executing the function.</p>
<p>Note the parent mse generates the child mse with extra options preceded with a plus sign. Their meanings are as follows:</p>
<pre>     +b means --batch-mode            +g means --global-env
     +e means --escape-char           +l means --local-env
     +m means --macro-symbol          +i means --inherited-env
     +v means --verbose               +s means --shared-env
</pre>
<p></p>
<pre>     +F means --friend-cid            +P means --pnode
     +I means --library-id            +T means --trace-level
     +V means --env-id
</pre>
<p></p>
<p>These options are collectively called environment options. The values &lt;env-id&gt;, &lt;pnode&gt;, and &lt;library-id&gt; are the id of the minishell environment, the pnode id, and the library id of the parent mse command, respectively.</p>
<h4>C6. Process arithmetic assignment</h4>
<p>If a simple statement is an arithmetic assignment of the form</p>
<pre>     &lt;variable_name&gt; = &lt;expression&gt;;
</pre>
<p></p>
<p>then the assignment statement will be executed using the same library as the 'calculate' command. The resulting string will be assigned to the variable specified on the left hand side, if any. This variable is stored in the mse command's minishell environment.</p>
<p>It is possible to format the result before assigning it to the variable. To this end, the options to the calculate command must be embedded inside a pair of square brackets before the &lt;expression&gt; as follows:</p>
<pre>     &lt;variable_name&gt; = [&lt;calculate's options&gt;] &lt;expression&gt;;
</pre>
<p></p>
<p>For more information, see example 18 on "Embedded options" in the calculate man page.</p>
<h4>C7. Process string assignment</h4>
<p>If a simple statement is a string assignment of the form</p>
<pre>     &lt;variable_name&gt; := &lt;string&gt;;
</pre>
<p></p>
<p>then all macros and escape sequences will be resolved in the context of the mse command. The resulting string will be assigned to the variable specified on the left hand side. This variable is stored in the command's minishell environment.</p>
<h4>C8. Process BALI commands</h4>
<p>If a statement cannot be identified by the format described in Sections C5 to C7, it is likely to be a BALI command. To this end the mse parent command will identify the leading keyword of the statement. Note that the first token in a statement is called the leading keyword. It can be an mse keyword such as "if", "for", "while", "BALI", "RPC", "RCC", etc. It can also be the name of a BALI command, including "mse".</p>
<p>If the leading token contains macros or escape sequences, the mse parent command will resolve the token to determine the actual keyword explicitly. As soon as the leading keyword is fully parsed and resolved, the mse parent command will decide what to do depending on the leading keyword.</p>
<h4>C8.1. MSE directive</h4>
<p>If the keyword is an MSE directive (such as if, while, for, foreach), the mse command continues to parse and expand the remaining tokens in the statement. The statement will be executed based on the syntax specs described in Sections C and D.</p>
<h4>C8.2. MSE built-in function or command</h4>
<p>If the keyword is a built-in function or built-in command, it will be executed in the context of the mse command.</p>
<h4>C8.3. BALI command</h4>
<p>If the leading keyword is a BALI command, the parent command will parse the text to find the end of the command line.  The resulting command line associated with the leading keyword is referred to as SUBLIST in the 'console' man page:</p>
<pre>        SUBLIST ::= PIPE [("&amp;&amp;"|"||") SUBLIST]
</pre>
<p></p>
<pre>        PIPE ::= COMMAND ["|" SIMPLE_COMMAND]
</pre>
<p></p>
<pre>        COMMAND ::= "{" LIST "}"
</pre>
<p></p>
<pre>        COMMAND ::= SIMPLE_COMMAND
</pre>
<p></p>
<p>The following are some SUBLIST examples:</p>
<pre>   (a) mse 'ls %file'
       'ls %file' is a SUBLIST.
       This SUBLIST has one simple command; the keyword is "ls".
</pre>
<p></p>
<pre>   (b) mse 'echo %abc | strquery --eq %xyz; ...'
</pre>
<p></p>
<pre>       The first SUBLIST has two simple commands; the leading keyword is "echo".
       Each simple command has a keyword. The keyword of the first simple
       command is "echo", the second is "strquery".
</pre>
<p></p>
<pre>   (c) mse 'pwd | strquery --has %mydir &amp;&amp; cat %myfile | strquery --has %foo; ...'
       The first SUBLIST has four simple commands:
          pwd | strquery --has %mydir &amp;&amp; cat myfile | strquery --has %foo
       The SUBLIST's leading keyword is "pwd".
</pre>
<p></p>
<p>In general, a SUBLIST can contain multiple simple commands. The mse command handles a SUBLIST as follows.</p>
<h4>C8.3.1. echo</h4>
<p>If the keyword of a simple command is "echo", it will be converted immediately to "mse-run echo" so that all the arguments of "echo" will be resolved in the context of the "mse-run" command as discussed below.</p>
<h4>C8.3.2. How does mse execute mse, mse-run, strquery, and strtoken?</h4>
<p>If the keyword of a simple command is one of the command names mentioned above, the interpreter behaves as follows.</p>
<p>1. Commands mse, mse-run, strquery</p>
<p>The interpreter does not resolve any variables in the command lines of these commands. Instead, it will leave this task to the child commands by automatically insert appropriate environment options between the command name and the first argument.  These extra options are to make the command share the same minishell environment and library as the root mse command. For example,</p>
<pre>    - "mse" becomes "mse +e @ +m % +s +V &lt;env-id&gt; +P &lt;pnode&gt; +I &lt;library-id&gt;"
    - "mse-run" becomes "mse-run +e @ +m % +s +V &lt;env-id&gt;"
    - "strquery" becomes "strquery +e @ +m % +s +V &lt;env-id&gt;"
</pre>
<p></p>
<p>Thus, example (b) above becomes:</p>
<pre>     (b1) mse 'mse-run  +e @ +m % +s +V &lt;env-id&gt; echo %abc | strquery +e @ +m % +s +V &lt;env-id&gt; --eq %xyz; ...'
</pre>
<p></p>
<p>and example (c) becomes:</p>
<pre>     (c1) mse 'pwd | strquery +e @ +m % +s +V &lt;env-id&gt; --has %mydir &amp;&amp; cat %myfile | strquery +e @ +m % +s +V &lt;env-id&gt; --has %foo; ...'
</pre>
<p></p>
<p>Consider another example:</p>
<pre>     (d) mse '{ mse echo Hello }'
</pre>
<p></p>
<p>The first mse command will modify the command in the script before running it as follows:</p>
<pre>     (d1) mse +V 140693095186128 +I 335 +F 335 +t 8 'echo Hello'
</pre>
<p></p>
<p>To prevent the first mse command from modifying the second mse command in the script, example (d) should be written as follows:</p>
<pre>     (e) mse '{ BALI mse echo Hello }'
</pre>
<p></p>
<p>The BALI keyword (see section D8.5. Then the first mse command will not modify the command immediately following the BALI keyword; i.e., it will simply run the first statement in the script as follows:</p>
<pre>     (e1) mse echo Hello
</pre>
<p></p>
<p>2. strtoken filter</p>
<p>a) Positional tokens</p>
<p>If the script is run with N arguments following the script name, the interpreter will resolve all positional tokens %0, %1, %2 to %N in the strtoken command line, leaving the rest intact to strtoken to resolve later. Thus, if N is zero, all positional tokens in the strtoken command line will be expanded by strtoken itself.</p>
<p>Note that strquery supports the --ntoken option that runs the strtoken filter in strquery's context. Thus, the rules above apply to both strtoken and strquery.</p>
<p>The rules are different for other commands in that all positional tokens greater than N will be replaced with an empty string because they correspond to non-existent arguments.</p>
<p>b) Macro tokens</p>
<p>The interpreter does resolve all macros in the strtoken command line.</p>
<h4>C8.3.3. Resolve escape sequences and macros</h4>
<p>All escape sequences and macros in individual simple commands will be resolved as follows:</p>
<p>a) For simple commands with the keywords listed in (C8.3.2), the parent does not resolve their command lines; they will be resolved in the context of the simple commands themselves later when they are executed.</p>
<p>b) For simple commands with the keywords not listed in (C8.3.2), all escape sequences and macros will be resolved in the context of the parent command. This task is done by walking from left to right, character by character:</p>
<pre>   - Escape sequences
     If the command encounters an opening verbatim escape sequence, it will find the
     matching closing verbatim escape sequence and then replace them with
     the text as shown in Table 4 of the quoted-text man page.
     All characters in this text will be treated as normal.
     See example 6 in the EXAMPLES section.
</pre>
<p></p>
<pre>   - Variable substitution:
         %{variable-name | positional-value | built-in-variable}
</pre>
<p></p>
<pre>   - Arithmetic substitution
         %((arithmetic-expression | built-in-function))
</pre>
<p></p>
<pre>   - Command substitution
         %(BALI command)
</pre>
<p></p>
<p>Consequently, the command line of example (b1) will be resolved as follows:</p>
<pre>    - %abc is resolved in the context of mse-run, not the leftmost mse command.
    - %xyz is resolved in the context of strquery, not the leftmost mse command.
</pre>
<p></p>
<p>Example (b2) will be resolved as follows:</p>
<pre>    - %mydir is resolved in the context of the leftmost strquery.
    - %myfile is resolved in the context of the leftmost mse (parent command).
    - %foo is resolved in the context of the rightmost strquery.
</pre>
<p></p>
<h4>C8.3.4. Execute BALI command</h4>
<p>After all macros and escape sequences are resolved, the parent mse command will execute the SUBLIST as a single BALI command. In other words, the parent mse command runs the SUBLIST command line as if the user were typing it directly in the BALI console.</p>
<p>Note if the command output is to be saved in a variable such as</p>
<pre>         mse 'x ::=. onode -f fs -o 2 | grep DataLength'   # see section D4.3
</pre>
<p></p>
<p>then the mse interpreter will execute the entire BALI command line 'onode -f fs -o 2 | grep DataLength' in mse's calling context. The status of the BALI command will be saved in a number of predefined variables as described in section D7.</p>
<p>Note the actual pnode where the command line is executed depends on the command's needs, which can be found in the man page or the output of 'help &lt;command&gt;'.</p>
<p>Let's examine how the command assignment above works. Suppose file system 'fs' is in evs 1, which, in turn, is hosted on physical node 2. This information can be found by running commands 'filesystem-list' and 'evs list', respectively.</p>
<p>Suppose the current context is cluster node 1, evs 1:</p>
<pre>         $ vn
         Current evs: 1
         Current cnode 1
</pre>
<p></p>
<p>We will run two mse commands in the above context.</p>
<p>Example 1:</p>
<pre>         $ mse 'x ::=. onode -f fs -o 2 | grep DataLength'
</pre>
<p></p>
<p>The mse interpreter executes the command line 'onode -f fs -o 2 | grep DataLength' in its context (evs 1, cnode 1). Note the onode command needs an EVS context and the current evs context is evs 1 (mse's calling context). Because evs 1 is hosted on cnode 2, the onode command, but not the grep, will be forwarded to cluster node 2 for execution. The final command output is assigned to the mse environment variable 'x', hence, x is defined on node 1 only.</p>
<p>Note that BALI commands can have different needs; dev users can see them by running:</p>
<pre>         $ test-command-forwarding-needs-
         test-command-forwarding-needs-admin
         test-command-forwarding-needs-cluster
         test-command-forwarding-needs-evs
         test-command-forwarding-needs-nothing
         test-command-forwarding-needs-tenant
</pre>
<p></p>
<p>Thus, command forwarding can occur depending on individual command needs, and the ultimate physical node that executes the command line can be the same as, or different from, the node where the mse interpreter is running.</p>
<p>Example 2:</p>
<pre>         $ mse --pnode 2 'var1 ::=. mse-set --terse var2 Hello'
</pre>
<p></p>
<p>The option '--pnode 2' causes the command line 'mse-set --terse var2 Hello' to run on node 2 instead of the node where mse is running.  Because mse-set has no needs, the evs context where mse is running is irrelevant.  So the command line will be forwarded to node 2 and its output is assigned to mse environment variable var1 on node 1.</p>
<p>Thus, the above command defines two mse environment variables:</p>
<pre>        - node 1 has variable var1=Hello and variable var2 undefined
        - node 2 has variable var2=Hello and variable var1 undefined
</pre>
<p></p>
<h4>C8.3.5. How does mse resolve conflicts of environment options?</h4>
<p>Environment options are those listed in subsection C8. They can be specified by users and can be auto-inserted by the mse command. Hence, some of them may be specified multiple times and can cause conflicts. To see this, let's reconsider example (3.b):</p>
<pre>   (b) mse 'echo %abc | strquery --eq %xyz; ...'
</pre>
<p></p>
<p>Suppose the user specifies an environment option to strquery:</p>
<pre>   (d) mse 'echo %abc | strquery -m ^ --eq ^xyz; ...'
</pre>
<p></p>
<p>After parsing and inserting auto-generated options, (d) becomes:</p>
<pre>   (d1) mse 'mse-run +e @ +m % +s +V &lt;env-id&gt; echo %abc | strquery +e @ +m % +s +V &lt;env-id&gt; -m ^ --eq ^xyz; ...'
                                                                                             &lt;--original --&gt;
Note that the escape character is defined twice for the strquery filter.
</pre>
<p></p>
<p>To resolve conflicts, all mse-aware commands are designed to accept multiple occurrences of the same environment options but only the last occurrences will be actually used. In a simple command line, the last occurrence of an option must be the values specified by the user because mse always adds the generated options between the command name and the first user-specified argument.</p>
<p>But if the user specifies the same option twice, say:</p>
<pre>   (e) mse 'echo %abc | strquery -m : -m ^ --eq ^xyz; ...'
</pre>
<p></p>
<p>then it is a user's mistake and the command should fail to conform to the standard behavior of most BALI commands.</p>
<p>To this end it is necessary to define the auto-generated option names differently from the user-specified option names. By design, the 'mse' command defines the auto-generated environment option names as follows:</p>
<pre>                 Table 1.  mse command's environment options
           +------------------------------------------------------+
           |  Auto-generated options  :  User-specified options   |
           |------------------------------------------------------|
           | +e or --+escape-char     :  -e or --escape-char      |
           | +m or --+macro-symbol    :  -m or --macro-symbol     |
           | +s or --+shared-env      :  -s or --shared-env       |
           | +V or --+env-id          :  -V or --env-id           |
           | +P or --+pnode           :  -P or --pnode            |
           | +I or --+library-id      :  -I or --library-id       |
           | +T or --+trace-level     :  -T or --trace-level      |
           +------------------------------------------------------+
</pre>
<p></p>
<p>Note that it is usually difficult for all mse-aware commands to standardize on the same user-specified environment option names, especially the short names, because of potential conflicts with other existing options. However, the auto-generated option names are unique because of their prefixes. Hence, all commands supporting minishell environments are required to standardize on the same auto-generated option names so that the mse command can work correctly.</p>
<h4>C8.3.6. How does mse execute commands with --eof option?</h4>
<p>The mse interpreter can recognize and process the --eof &lt;marker&gt; option that appears in the command line of the following commands:</p>
<pre>       mse, wrdata, sswrdata, env-set, mse-set, myenv-set
</pre>
<p></p>
<p>The behavior of the "--eof &lt;marker&gt;" option is consistent for all the commands listed above. Specifically, when such a command is run in a BALI console, the command will read the standard input until it sees a &lt;marker&gt; token in a separate line by itself. This line terminates the data; the command will discard this line and the newline preceding it (see the 'wrdata' man page for an example).</p>
<p>When such a command is specified with an --eof option in an mse script (called the target command), the mse interpreter will process this option if the option name is spelled out in full, i.e., "--eof", not "--eo".</p>
<p>If the option is specified exactly as "--eof" in an mse script, the mse command will treat all lines below the target command line as data until it sees a &lt;marker&gt; token in a separate line by itself. The mse command then discards the last line and the newline preceding it. It will pass the remaining data to the target command and then run the target command as if the --eof option were removed.</p>
<p>If the --eof option is specified partially as --eo, the mse command does not process it. Therefore, when the target command line is executed by mse, the target command will see the --eo option passed to it, and hence, will read data from the standard input interactively.</p>
<pre>        Example:
            $ sscat test.scr
            # Read data in script by specifying the full option name: --eof
            mse-set --eof END username
            hoc
            END
</pre>
<p></p>
<pre>            # Read data interactively by specifying just --eo
            echo -n "Enter %username's password followed by END on the next line:";
            mse-set --eo END password
            echo Now authenticate user %username...
</pre>
<p></p>
<pre>            $ sscat -f test.scr
            Enter hoc's password followed by END on the next line: abc123
            END
            Now authenticate user hoc...
</pre>
<p></p>
<p>Note that the six commands above, when specified with --eof, can appear in a command assignment (see Sections D4.3.3 to D4.3.5).  For example,</p>
<pre>        Example:
            $ sscat test1.scr
            # Read data in script by specifying the full option name: --eof
            output ::=: mse-set -v --eof END username
            hoc
            END
</pre>
<p></p>
<h3>C9. Script file name</h3>
<p>All script or library files should be named with an ".mse" extension. However, the command can accept existing BALI scripts with a ".scr" extension. In this case the command will automatically adds a semicolon to each line of the .scr script to make the line a legal mse statement.</p>
<p>Because support for function is specific to mse and can never be found in a BALI script, the mse command strictly enforces the ".mse" extension on library file names.</p>
<p>Note that mse allows the base name of a library file to be used in the fully qualified function name. Thus, the base name must not contain special characters that can break the parser. For instance, one can legally create a library file named "ab{cd.mse" but cannot call any of its functions using FQFN because it will break the parser:</p>
<pre>       mse 'call ab{cd.mse::foo'
</pre>
<p></p>
<p>Thus the rule of thumb is to name the script or library file as if it were the name of a variable.</p>
<p>The following sections describe the minishell environment and the script syntax.</p>
<h3>C10. Global MSE variables</h3>
<p>Each physical node possesses a single global minishell environment on system start-up. This environment will go away on system reboot. Commands that claim to support MSE can add variables to, or remove variables from, this global environment. Thus, all global MSE variables are visible to all MSE-aware commands.</p>
<p>Examples of commands that support global MSE are:</p>
<pre>   * mse-set    -- creates a global MSE variable
   * mse-unset  -- removes a global MSE variable
   * mse-env    -- lists all global MSE variables
   * mse        -- runs a C-like script, which can contain global MSE variables
   * calculate  -- computes an expression (algebraic, logical, or string)
</pre>
<p></p>
<p>A command that operates in the global MSE can have access to variables in the BALI shell. If the command creates a new variable, the variable will be stored in the global MSE. If it needs to use a variable value, it will search the variable in the global MSE first, then in BALI.</p>
<h3>C11. Local MSE variables</h3>
<p>A command that claims to support its own minishell environment is said to operate in its local MSE. This local environment exists during the life time of the instance of the command. Different instances of the same command have separate local minishell environments.</p>
<p>A command that operates in a local MSE has access to variables in the global MSE and the BALI shell. If the command creates a new variable, the variable will be stored in the local MSE. If it needs to use a variable value, it will search the variable in the local MSE first, then the global MSE, and finally in BALI.</p>
<p>By default, the 'mse' command operates in the global MSE. But if option --local-env is specified, each instance of the 'mse' command will operate in its local MSE. Variables defined in the local MSE of one 'mse' instance cannot be accessed by any other 'mse' instances or by any other commands.</p>
<h3>C12. Variable Scope</h3>
<p>The scope of a variable, depending on individual commands, can be a local MSE, the global MSE, or the BALI environment. The following diagram shows the relationships among these environments. Each environment is represented by a connected area. Thus, the intersection between two environments is empty. The diagram shows that an environment can access variables in the inner environment (as indicated by arrows) but not variables in the outer environment.</p>
<pre>     +---------------------------------------------------------------+
     |  Local MSE (destroyed on command instance termination)        |
     |         |                                    |                |
     |    +----|------------------------------------|------------+   |
     |    |    V                                    |            |   |
     |    |  Global MSE (persistent until reboot)   |            |   |
     |    |          |                              |            |   |
     |    |    +-----|------------------------------|--------+   |   |
     |    |    |     V                              V        |   |   |
     |    |    |                                             |   |   |
     |    |    | BALI environment (persistent until reboot)  |   |   |
     |    |    |                                             |   |   |
     |    |    | Ex1: calculate x=3                          |   |   |
     |    |    +---------------------------------------------+   |   |
     |    |                                                      |   |
     |    | Ex2: calculate --minishell y=7                       |   |
     |    +------------------------------------------------------+   |
     |                                                               |
     |  Ex3:  mse --local 'z=9; echo x=%x, y=%y, z=%z'               |
     +---------------------------------------------------------------+
</pre>
<p></p>
<p>Note that example 1 creates variable x in BALI and sets it to 3. As a result,</p>
<pre>    $ env --name x           # dump variable in BALI
    x=3
</pre>
<p></p>
<pre>    $ mse-env --name x       # dump variable in global MSE
    Undefined variable name: x
</pre>
<p></p>
<p>Example 2 creates variable y in the global minishell environment and sets it to 7.  As a result,</p>
<pre>    $ mse-env --name y
    y=7
</pre>
<p></p>
<pre>    $ env --name y             # BALI cannot see y
    Undefined variable name: y
</pre>
<p></p>
<pre>    $ mse 'echo x=%x, y=%y'    # mse sees variables in two environments
    x=3, y=7
</pre>
<p></p>
<p>Example 3 creates variable z in the local minishell environment of the current instance of the mse command.  As a result,</p>
<pre>     $ mse --local 'z=9; echo x=%x, y=%y, z=%z'
     x=3, y=7, z=9
</pre>
<p></p>
<p>If we run another instance of the mse command, it does not know about z:</p>
<pre>     $ mse 'echo x=%x, y=%y, z=%z'   # this mse instance uses global MSE
     x=3, y=7, z=
</pre>
<p></p>
<h3>C13. Variable Substitution</h3>
<p>Resolving escape sequences and performing variable substitution are both carried out in phase 2 (see section C4) when the text is scanned from left to right.</p>
<p>Note that the BALI shell processes a command line completely before delivering the result to the command, which is the first word on the command line. Specifically, it evaluates all tokens that start with a dollar sign in text enclosed by double quotes. Similarly, all commands that support MSE must evaluate all tokens that start with a percent sign before beginning further processing. The difference between BALI and MSE is that MSE treats the single quotes and double quotes identically; the text enclosed by single quotes or double quotes is subject to the same variable substitution.</p>
<p>As an example, suppose DAY is a BALI environment variable that stands for "Monday". The following examples illustrate the point:</p>
<pre>    $ echo "I see you on $DAY"         # (1)
    I see you on Monday
</pre>
<p></p>
<pre>    $ echo "I see you on %DAY"         # (2)
    I see you on %DAY
</pre>
<p></p>
<pre>    $ mse 'echo "I see you on %DAY"'   # (3)
    I see you on Monday
</pre>
<p></p>
<p>Variable substitution occurred in (1) because the BALI shell saw the dollar sign as a special token for variable substitution. No substitution occurred in (2) because the BALI shell saw the percent sign as a normal character. Variable substitution occurred in (3) because the mse command processed the text and saw % as a special character that triggers variable substitution.</p>
<p>Note that the variable name can be enclosed in curly brackets to avoid ambiguity or to change the order of substitution. For example,</p>
<pre>  a) To avoid ambiguity
</pre>
<p></p>
<pre>     $ mse 'echo "I see you on %{DAY}s"'  # %DAYs cannot be resolved
     I see you on Mondays
</pre>
<p></p>
<pre>  b) To change order of substitution
</pre>
<p></p>
<pre>     Suppose we also defined N=4 and DAY4='Wednesday'. Then
</pre>
<p></p>
<pre>     $ mse-set N 4
     $ mse-set DAY4 Wednesday
     $ mse 'echo "I see you %DAY%N"'
     I see you Monday4
</pre>
<p></p>
<pre>     $ mse 'echo "I see you %{DAY%N}"'
     I see you Wednesday
</pre>
<p></p>
<p>Note that the bash shell does not support this feature, i.e., the following example will fail in the bash shell:</p>
<pre>     $ N=4
     $ DAY=Wednesday
     $ echo I see you on ${DAY$N}
     bash: ${DAY$N}: bad substitution
</pre>
<p></p>
<h2>D. Introduction to Minishell Scripting</h2>
<p>A minishell environment script is a sequence of BALI commands and minishell directives (also known as commands) where the flow of execution is controlled by C-like constructs.</p>
<h2>D1. Sample MSE Script</h2>
<p>The following is a silly minishell script just to illustrate the syntax. The script can be stored in a file in flash, say example1.mse.</p>
<pre>             $ sscat example1.mse
   Line 1:   for (i = 0; i &lt; 10; i = i + 1) {
   Line 2:      x=i*i;
   Line 3:      echo The square value of %i is %x;
   Line 4:      if (x == 30) {
   Line 5:         abort;            # meaning exit the current mse with FAILED status
   Line 6:      } else if (x &gt; 45) {
   Line 7:         done;             # meaning exit the current mse with SUCCESS status
   Line 8:      }
   Line 9:   }
</pre>
<p></p>
<p>Note that the "Line n" tags are not part of the script.  They have been added to the listing to make it easier to describe the "Observations" section below.</p>
<p>The script can be executed as follows:</p>
<pre>   # Example 1
   $ mse --file example1.mse
</pre>
<p></p>
<p>Or the script can also be typed on one line on a BALI console:</p>
<pre>   # Example 2
   $ mse 'for (i=0;i&lt;10;i=i+1) { x=i*i; echo The square value of %i is %x; if (x&gt;30) {abort;} else if (x&gt;45) {done;} }'
</pre>
<p></p>
<p>We can force the script to use its local minishell environment</p>
<pre>   # Example 3
   $ mse --local 'for (i=0;i&lt;10;i=i+1) { x=i*i; echo The square value of %i is %x; if (x&gt;30) {abort;} else if (x&gt;45) {done;} }'
</pre>
<p></p>
<h2>D2. Observations</h2>
<p>1. The curly brackets are called delimiters. Users can specify a different pair of delimiters if desired.</p>
<p>2. Line 1 looks like a for-loop in the C language. In fact, mse enforces C syntax on all flow controls.</p>
<p>3. C variables are used on the fly and are stored in the minishell environment. In Examples 1 and 2 the two variables i and x are stored in the global minishell environment. They can be checked by running 'mse-env'. In Example 3 the two variables i and x are stored in the minishell environment local to the instance of the mse command. This environment goes away when the command terminates.</p>
<p>4. By default, the percent sign is defined as the macro symbol. See the macro-support man page for more information. In a nutshell, if a string is preceded by a macro symbol, it is interpreted as a variable and the entire token (macro symbol plus the string) will be replaced with the value of the variable.</p>
<p>5. Integer variables are assumed 64-bit signed integers. Arithmetics are supported using the same library as the 'calculate' command. Almost all C/C++ operators are supported except the increment and decrement operators (e.g., i++ is invalid).</p>
<p>6. If the macro symbol is the percent sign, arithmetic expressions that involve modulo must specify the modulo operator as ".mod." instead of "%" to avoid conflict. See the 'calculate' man page for more information.</p>
<p>7. All conditional statements in the C language are supported (i.e., statements using logical operators ==, !=, &lt;, &lt;=, &gt;, &gt;=, &amp;&amp;, ||) The operands can be numerical, logical, or string expressions. Curly brackets are required in if-else constructs. In general, the use of curly brackets is recommended so that all the tokens can be parsed correctly. See section D5.1 for details.</p>
<p>8. Comments are supported only in script files.</p>
<h2>D3. MSE Comments and Script File Preprocessor Directives</h2>
<h3>D3.1. Bash-style comments</h3>
<p>By default, only the bash style of "#" comment is supported, subject to the following limitations.</p>
<p>To identify comments, the mse command has to discard all leading and trailing white spaces on a line. The resulting line will be processed as follows.</p>
<p>D3.1.1. The line is a comment if it is empty (blank).</p>
<p>D3.1.2. If the '#' token does not occur at the start of the line, all characters from the comment token to the end of the line are considered comment if and only if the first graphic character that precedes it is in the set ";{}()". In addition, the character immediately before the comment token must be a white space character or ";".</p>
<pre>    if (i &gt; 3) {   # this is a comment starting from the hash character
      echo Hello;  # this text is a comment
      echo Good;# this text is also a comment
      echo Good # this text is also a comment because '#' is preceded by a space
      echo Bad# this text is also not a comment and will be echo'ed
    }              # this is a comment
</pre>
<p></p>
<p>At the present time, the parser does not maintain state information between script lines. Therefore, using trailing comments in statements that have dangling quotes can result in wrong parsing. In particular, trailing comments used with string assignments can lead to incorrect parsing (see examples in section D4.2).</p>
<p>To ensure correct comment parsing, one can:</p>
<pre>   - specify a "#trailing_comment_token" directive,
   - or avoid using trailing comments and always use full-line comments.
</pre>
<p></p>
<p>D3.1.3. The line is a comment if it starts with "#" unless "#" is part of the following preprocessor directives:</p>
<pre>       #include "&lt;file&gt;"
       #define &lt;variable&gt;
       #undef &lt;variable&gt;
       #ifdef &lt;variable&gt;
       #ifndef &lt;variable&gt;
       #if &lt;value&gt;
       #endif
</pre>
<p></p>
<pre>       #trailing_comment_token &lt;string&gt;
       #option &lt;name&gt; [&lt;value&gt;]
       #run &lt;command line&gt;
       #discard_comment_in_continuation_lines [yes|no]
       #concatenation_begins
       #concatenation_ends
</pre>
<p></p>
<p>The first seven directives behave like their C counterparts with the following limitations.</p>

<p>- There is a limit of 100 nested #include files (this can be change by poking the C variable mse::max_include_files)</p>
<p>- If an #include file is encountered twice, the command will fail to avoid recursive includes whether the #include file is nested or not. To avoid this, one can add a #ifndef directive to the top of a file to prevent it from being included multiple times.</p>

<p>Support for "#if &lt;value&gt;" is very limited; the command will interpret any pair of "#if 0" and "#endif" as an indication to skip all lines bracketed between them. Other patterns of "&lt;value&gt;" are not interpreted at the present time; the command simply increments the "#if" counter in order to check against the number of #endif tokens and will process text bracketed between them as real script text.</p>
<p>Note that the #define directive is very restrictive in that it does not allow the variable to accept any value.</p>
<p>To define a variable and assign a value, use the #run directive to run a command such as env-set or mse-set. If a variable is defined this way, it can be undefined by using the #run directive to run a command such as env-unset or mse-unset. For more information, see D3.5.</p>
<h3>D3.2. Double-slash style comments</h3>
<p>If option -w|--allow-double-slash-style-comment is specified, the "//" token can be used to signify a comment similar to the C++ language. However, the mse command only treats "//" as the start of a comment in two cases:</p>
<p>* when it appears as the first graphic token in a line,</p>
<p>* or when it meets the rules in D3.1.2, with '#' replaced with "//".</p>
<h3>D3.3. Trailing comment token directive</h3>
<p>The comment parser is very primitive; it is not aware of the minishell syntax and does not maintain state information between lines.  It knows how to find word boundaries as long as the words are on the same line. Its sole mission is to strip off comments and concatenate all the remaining tokens to form an mse script.  Syntax error will be detected later when the mse command parses the script and executes statements by statements.</p>
<p>To help the comment parser identify trailing comments correctly, one can specify a special token that marks the beginning of the trailing comment on a line. All characters starting from this marker to the end of the line are treated as comment and are discarded.</p>
<p>For instance, an mse script file may contain the following lines:</p>
<pre>       #trailing_comment_token ###
</pre>
<p></p>
<pre>       echo Tom's letter ### Or Mary's letter?
</pre>
<p></p>
<p>The final script becomes:</p>
<pre>       echo Tom's letter
</pre>
<p></p>
<p>Without this directive, "###" is part of the text to echo because the comment parser considers all text between the starting quote and the next matching quote, or the end of line, whichever occurs first, to be the text of a single word. After the preprocessing phase the final script will become:</p>
<pre>       echo "Tom's letter ### Or Mary's letter?"
</pre>
<p></p>
<h3>D3.4. The #option directive</h3>
<p>This option directive is used to change an option to the mse command. Currently the following options are supported because they specify how to preprocess the script file:</p>
<h3>D3.4.1. Handling newlines</h3>
<pre>   #option --newline-as-command-separator [false]
   #option -n [false]
</pre>
<p></p>
<p>These two options are synonymous and are described in section B. If "false" is not specified, the preprocessor can add missing command separator (default is semi-colon) to BALI command lines. Otherwise, the preprocessor enforces command separators to conform to the mse statement syntax.</p>
<h3>D3.4.2. Handling double slash comments</h3>
<pre>   #option --allow-double-slash-style-comment [false]
   #option -w [false]
</pre>
<p></p>
<p>These two options are synonymous and are described in section B. If "false" is not specified, the preprocessor support double-slash style comments. Otherwise, the preprocessor does not support double-slash style comments.</p>
<h3>D3.4.3. Handle global minishell environment on startup and exit</h3>
<pre>   #option --clear-global-env-on-start-and-exit
   #option -Z
</pre>
<p></p>
<p>These two options are synonymous and are described in section B. They tell the interpreter to clear all variables from the global minishell environment on startup and on exit.</p>
<h3>D3.4.4. Display summary of unit testing</h3>
<pre>   #option --display-summary-on-exit
   #option -Y
</pre>
<p></p>
<p>These two options are synonymous and are described in section B. They tell the interpreter to display a summary of unit testing upon exit.</p>
<h3>D3.4.5. Minimum number of mse unit tests</h3>
<pre>   #option --minimum-mse-unit-tests-expected &lt;num&gt;     (default : 0)
</pre>
<p></p>
<p>This directive tells the interpreter that the mse script must execute at least &lt;num&gt; unit tests. Thus, if mse executes less than &lt;num&gt; unit tests upon exit, it will display "SCRIPT FAILED" when the setting --display-summary-on-exit is true.</p>
<h3>D3.4.6. Maxmimum number of strquery's failed results</h3>
<pre>   #option --maximum-strquery-failed-results-allowed &lt;num&gt;     (default : 0)
</pre>
<p></p>
<p>This directive tells the interpreter that all reporting strquery's in the script must produce no more than &lt;num&gt; failed results upon exit. Thus, if mse sees more than &lt;num&gt; failed tests from strquery upon exit, it will display "SCRIPT FAILED" when the setting --display-summary-on-exit is true.</p>
<h3>D3.4.7. Delete script on completion</h3>
<pre>   #option --delete-script-on-completion
</pre>
<p></p>
<p>This directive tells the interpreter that the mse script must be removed after mse runs to completion. This is helpful in cases where the script is copied from another server for testing and needs to be cleaned up when the test is done.</p>
<h3>D3.5. The #run directive</h3>
<p>Syntax:</p>
<pre>    #run &lt;command line&gt;
</pre>
<p></p>
<p>This directive causes the specified command to be executed and removed during the preprocessing phase. When the preprocessor reaches the line containing the #run directive, it will immediately change the "#run" token to %%(run)". The line then becomes</p>
<pre>   %%(run) &lt;command line&gt;
</pre>
<p></p>
<p>and is left in the script. This line will be  executed and then removed from the script during the second pass of the preprocessing phase (see Section C4.1). A use case is defining or undefining environment variables during the preprocessing phase.</p>
<h3>D3.6. The #discard_comment_in_continuation_lines directive</h3>
<p>This directive is supported in release 14.6914.</p>
<p>Syntax:</p>
<pre>    #discard_comment_in_continuation_lines [value = yes|no]
</pre>
<p></p>
<p>The value is case-insensitive and the default is yes. Alternatives to 'yes' are ok, true, enabled, or any nonzero value such as 1. Alternatives to 'no' are false, disabled, or 0.</p>
<p>If the value is 'yes', all leading or trailing comment in a continuation line is discarded before concatenation. This is the new default behavior of mse starting with release 14.6914.</p>
<p>If the value is 'no', all leading or trailing comment in a continuation line is kept for concatenation.  This is the default behavior of mse before release 14.6914.</p>
<p>The directive affects all subsequent lines in an mse script until the same directive appears again with a different value.</p>
<h3>D3.7. The #concatenation_begins and #concatenaton_ends directives</h3>
<p>All lines between these two directives are concatenated to form a single line.</p>
<p>Before concatenation, all lines are pre-processed to recognize directives, escape sequences, quoted text, and comments.</p>
<h2>D4. MSE Assignment Statements</h2>
<p>MSE supports assignment statements in five formats:</p>
<h3>D4.1. Arithmetic assignment statement</h3>
<pre>   Syntax:  &lt;mse variable&gt; = &lt;expression&gt;
</pre>
<p></p>
<p>Here, &lt;expression&gt; can be a single number, an algebraic or logical expression that contains only numeric data and/or functions as listed in Table 2 of the 'mse-functions' man page.</p>
<p>The mse command evaluates the assignment by passing the entire statement as is to the 'calculate' library, which is the engine of the 'calculate' command. Thus, in general, &lt;expression&gt; is evaluated to an integer result, which is then assigned to the specified minishell variable. The syntax of &lt;expression&gt; is the same as &lt;expression&gt; in the 'calculate' command.</p>
<p>Note that environment variables can appear in the expression. If the variables are specified with a leading macro symbol, they will be evaluated when the expression is parsed. If specified without a leading macro symbol, they will be evaluated when the expression is computed.</p>
<pre>    $ mse-set msg "Hello Tom"
</pre>
<p></p>
<pre>    $ mse 'len=4*strlen(msg); echo len = %len'  # success
    len = 36
</pre>
<p></p>
<p>Note that the entire right hand side, "4*strlen(msg)", is passed to the library of the 'calculate' command. Thus, the strlen function sees the msg token literally as is. So it interprets msg as a variable and hence can retrieve its value and compute the length.</p>
<pre>    $ mse 'n=strlen(%msg)'  # fail
</pre>
<p></p>
<p>After parsing, the mse script becomes: "n=strlen(Hello Tom)". The library of the 'calculate' command is invoked to evaluate the right hand side. The result is that the argument of the strlen function has two separate variables Hello and Tom, which is a syntax error. To fix this error:</p>
<pre>    $ mse 'n=strlen("%msg")'  # success
</pre>
<p></p>
<h3>D4.2. String assignment statement</h3>
<p>A literal string can be assigned to a variable directly by using a string assignment operator ":=". Alternatively, it can be specified as an argument to one of the quoting functions, which is then assigned to a variable using an arithmetic assignment operator "=".</p>
<h3>D4.2.1. Using string assignment operator ":="</h3>
<pre>   Syntax:  &lt;mse variable&gt; := &lt;string&gt;
</pre>
<p></p>
<p>This syntax assigns the specified string to the MSE variable on the left hand side. The command parses the right hand side (RHS) as follows:</p>

<p>* If the RHS is terminated with a command separator (default is semicolon), the command separator will be removed.</p>
<p>* If the resulting string contains leading and/or trailing spaces, these spaces are then removed.</p>
<p>* If the resulting string is enclosed in either single or double quotes, the enclosing quotes will be removed.</p>
<p>* The resulting string, even if it contains command separators or comment token #, will then be assigned to the variable.</p>

<p>But if the text contains quotes that can lead to unmatching quote errors or incorrect parsing, the entire text should be enclosed with appropriate quotes or the quotes should be replaced with an appropriate escape sequence.</p>
<p>This behavior is supported to reduce quotes and hence make it easier to run nested commands.</p>
<pre>    Example:
</pre>
<p></p>
<pre>    $ sscat test.mse
    x := "Joe's book"  ;
    echo /%x/;
    y := Land "O'"Lake  ;
    echo /%y/;
    z :=Good   work  ;
    echo /%z/;
    t := Joe's book  ; # not Mary's book
    echo /%t/;
</pre>
<p></p>
<pre>    $ mse -f test.mse
    /Joe's book/
    /Land O'Lake/
    /Good   work/
    /Joe's book  ; # not Mary's book/
</pre>
<p></p>
<p>The following example gives parsing errors because of unmatched quotes:</p>
<pre>    t := Joe's book  ;
    echo /%t/;
</pre>
<p></p>
<h3>D4.2.2. Using quoting functions with arithmetic assignment operator "="</h3>
<pre>   Syntax:  &lt;mse variable&gt; = &lt;expression of quoting functions&gt;
</pre>
<p></p>
<p>Recall that the arithmetic assignment operator, '=', invokes the library of the 'calculate' command to evaluate the expression on the right hand side of the equal sign, and then assign the result to the variable on the left hand side of the equal sign. The expression can contain any functions listed in Table 2 of the 'mse-functions' man page. In particular, the library supports the following four quoting functions:</p>
<pre>     str(s), qstr(s), dqstr(s), and esc(s),
</pre>
<p></p>
<p>where s is a literal string bounded by the parentheses. The parentheses can be replaced with other delimiters as described in the cited man page. These functions play the role of a pair of double or single quotes that is used to delimit a string. Thus, all characters in the string delimited by these functions are literal except the escape character (default is '@') and the macro symbol (default is '%').</p>
<p>Note that string concatenation is performed by operator '+', and string repeat by operator '*'. For the repeat operator, one operand must be a string or a function returning a string, and the other operand must be a number or a variable with numeric value.</p>
<pre>    $ sscat test1.scr
    x = str(abc[]{}&lt;&gt;;'"&amp;$);
    echo x = /%x/
    # Using "/x/" tag to serve as parentheses:
    y = str/x/abc(){}[]{} / | ! #&lt;&gt;;'"&amp;$/x/;
    echo y = /%y/
    # Concatenate and repeat operators
    z = str(abc:)*2 + ",def"*2
    echo z = /%z/
</pre>
<p></p>
<pre>    $ mse -f test1.scr
    x = /abc[]{}&lt;&gt;;'"&amp;$/
    y = /abc(){}[]{} / | ! #&lt;&gt;;'"&amp;$/
    z = /abc:abc:,def,def/
</pre>
<p></p>
<p>The following two examples produce the same output as given in section D4.2.1.</p>
<pre>    $ sscat test2.mse
    x = str(Joe's book) ;
    echo /%x/;
    y = str(Land O'Lake)  ;
    echo /%y/;
    z = str(Good   work)  ;
    echo /%z/;
    t = str(Joe's book  ; # not Mary's book)
    echo /%t/;
</pre>
<p></p>
<pre>    $ sscat test3.mse
    # Replace single quote by esc(q) function
    x = str(Joe)+esc(q)+str(s book)  ;
    echo /%x/;
    y = str(Land O)+ esc(q) + str(Lake)  ;
    echo /%y/;
    z = str(Good) + esc(_)*3 + str(work)  ;
    echo /%z/;
    t = str(Joe's book  ; # not Mary's book);
    echo /%t/;
</pre>
<p></p>
<p>Note that the space surrounding the str() functions is insignificant. For more information, see examples 25 and 26 in the 'calculate' man page.</p>
<h3>D4.2.3. Using other string expressions with arithmetic assignment operator "="</h3>
<p>All functions returning a string in Table 2 of the 'calculate' command can be used in the right hand side of an arithmetic assignment operator. All strings can be concatenated and/or repeated to form a larger string.</p>
<p>Example:</p>
<pre>    s = "book pen";
    t = "choose" + 3*strstr(s, " ");
    # Output: choose pen pen pen
</pre>
<p></p>
<h3>D4.3. Command status assignment</h3>
<p>When mse runs a BALI command, it maintains two command status values which are related as follows:</p>
<pre>                BALI command status          :  Linux-equivalent status
           ----------------------------------:---------------------------
             10 (success)                    :        0 (success)
             11 (failed, syntax displayed)   :        2 (syntax)
             12 (failed)                     :        1 (failed)
</pre>
<p></p>
<p>The status values can be assigned to a variable using the following syntax:</p>
<pre>      (a) &lt;mse variable&gt; ::= &lt;BALI command line&gt;     # interested in BALI command status
      (b) &lt;mse variable&gt; .:= &lt;BALI command line&gt;     # interested in Linux-equivalent status
</pre>
<p></p>
<p>If &lt;mse variable&gt; is "devnull", no assignment is made. Otherwise, mse will create a companion built-in variable by prefixing the specified variable with ".rc_" and proceed as follows:</p>
<pre>   * For syntax (a):
      - assign the BALI command status to the specified variable, and
      - assign the Linux-equivalent status to the companion built-in variable.
</pre>
<p></p>
<pre>   * For syntax (b):
      - assign the Linux-equivalent status to the specified variable, and
      - assign the BALI command status to the companion built-in variable.
</pre>
<p></p>
<p>Example:</p>
<pre>     $ mse 'status ::= echo abc'
     $ mse-env
     status=10
     .rc_status=0
</pre>
<p></p>
<pre>     $ mse 'status .:= echo abc'
     $ mse-env
     status=0
     .rc_status=10
</pre>
<p></p>
<p>Note the following BALI command stores the BALI command status in a variable in the BALI environment:</p>
<pre>         backquote --numeric-status &lt;BALI variable&gt; -- &lt;command&gt;
</pre>
<p></p>
<h3>D4.4. Command output assignment</h3>
<pre>   Syntax:
      (a)   &lt;mse variable&gt;  ::=. &lt;BALI command line&gt;    # interested in BALI command status
      (b)   &lt;mse variable&gt;  .:=. &lt;BALI command line&gt;    # interested in Linux-equivalent status
</pre>
<p></p>
<p>This syntax runs the specified BALI command and, if the &lt;mse variable&gt; is not "devnull", it will do as follows:</p>
<pre>   * assign the command output to the specified MSE variable.
   * create a companion built-in variable by prefixing the specified variable with ".rc_".
      - For syntax (a), save the BALI command status to the companion built-in variable.
      - For syntax (b), save the Linux-equivalent status to the companion built-in variable.
</pre>
<p></p>
<p>Example:</p>
<pre>     $ mse 'output ::=. echo abc'
     $ mse-env
     output=abc
     .rc_output=10
</pre>
<p></p>
<pre>     $ mse 'output .:=. echo abc'
     $ mse-env
     output=abc
     .rc_output=0
</pre>
<p></p>
<p>Note the following BALI command stores the BALI command output in a variable in the BALI environment:</p>
<pre>         backquote &lt;BALI variable&gt; &lt;command&gt;
</pre>
<p></p>
<h3>D4.5. Command output and error assignment</h3>
<pre>   Syntax:
      (a)   &lt;mse variable&gt;  ::=: &lt;BALI command line&gt;    # interested in BALI command status
      (b)   &lt;mse variable&gt;  .:=: &lt;BALI command line&gt;    # interested in Linux-equivalent status
</pre>
<p></p>
<p>This syntax runs the specified BALI command and, if the &lt;mse variable&gt; is not "devnull", it will do as follows:</p>
<pre>   * assign the combined output and error messages to the specified MSE variable.
   * create a companion built-in variable by prefixing the specified variable with ".rc_".
      - For syntax (a), save the BALI command status to the companion built-in variable.
      - For syntax (b), save the Linux-equivalent status to the companion built-in variable.
</pre>
<p></p>
<p>Example:</p>
<pre>     $ mse 'output_and_error ::=: ls'
     $ mse-env
     output_and_error=error: VolumeNotFound.
     .rc_output_and_error=12
</pre>
<p></p>
<pre>     $ mse 'output_and_error .:=: ls'
     $ mse-env
     output_and_error=error: VolumeNotFound.
     .rc_output_and_error=1
</pre>
<p></p>
<p>Note the following BALI command stores the BALI command output and errors in a variable in the BALI environment:</p>
<pre>         backquote --capture-stderr --force &lt;BALI variable&gt; &lt;command&gt;
</pre>
<p></p>
<p>Note that all variables on the left hand sides of D4.1 to D4.5 and on the right hand side of D4.1 are not preceded by a macro symbol. All variables on the right hand sides of D4.2 to D4.5 must be preceded by a macro symbol character.</p>
<p>Note:</p>
<p>The common characteristics of assignments of various types are that the left hand side is a valid variable name. However, some commands allow the first argument to be an assignment symbol. For example,</p>
<pre>          x = 7;       #  no ambiguous: assignment
          ls = 40;     #  ambiguous: assignment or command ?
          ls=40;       #  no ambiguous: assignment
          echo =Hello; #  ambiguous: assignment or command ?
          echo=40;     #  no ambiguous: assignment
</pre>
<p></p>
<p>By design, an ambiguous statement is interpreted as assignment except for cases where the variable name is one of some commonly used commands such as echo, ls, mv, rm, rmdir, cat, touch, trunc, wrfile, etc.</p>
<p>To override the default interpretation:</p>
<pre>   * To indicate an assignment: leave no spaces surrounding the assignment symbol.
          echo=Hello
</pre>
<p></p>
<pre>   * To indicate a command, precede the command name with the BALI keyword:
          BALI ls = 40
</pre>
<p></p>
<h2>D5. MSE Flow Control Highlights</h2>
<p>The body of all flow controls should be enclosed in a pair of curly brackets to ensure correct parsing.</p>
<p>The script supports arithmetic assignments and conditional statements similar to those in the C programming language. All the expressions are evaluated using the 'calculate' command library, which is described in the 'mse-functions' man page.</p>
<h3>D5.1. Support for conditional</h3>
<p>Releases 13.0 and earlier support conditionals involving numerical expressions or numbers only. Starting with release 13.1, conditionals can contain numerical or string expressions similar to the C programming language. The syntax is as follows:</p>
<pre>    if (conditional) {
       statements;
    [ [
    } else if (conditional) {
       statements;  ]
    } else {
       statements;    ]
    }
</pre>
<p></p>
<p>All the conditional expressions inside the if-statement above must have the same syntax as the &lt;expression&gt; argument to the 'calculate' command.</p>
<p>Note that one can use 'strquery', which can be run as a command or filter, to convert string conditionals into a number and then use it in the if-statement.</p>
<p>For example, the following code</p>
<pre>    if ("%weekday" == "Monday") {
       echo Today is Monday.;
    }
</pre>
<p></p>
<p>can be replaced with the following:</p>
<pre>    x ::=. echo %weekday | strquery --eq Monday;
    # Or run strquery as a command:
    # x ::=. strquery --first-string "%weekday" --eq Monday;
    if (x) {
       echo Today is Monday.;
    }
</pre>
<p></p>
<p>The strquery command/filter can compute any arbitrary expression of strings. The command has too many functionalities to be described adequately in just a few paragraphs. However, we will show a few examples to see how strquery can be used to convert conditional statements involving string expressions into numerical conditionals.</p>
<p>All the examples use the following string variable:</p>
<pre>    s := "He buys a bag of apples, bananas, and oranges.";
</pre>
<p></p>
<p>1) Logical string expressions with a single operator</p>
<pre>    if (strcasecmp(s, "apples") &lt; 0) ...
    Same as:    x ::=. strquery --first-string "%s" --lt apples;
                if (x) ...
</pre>
<p></p>
<pre>    if (strstr(s, "apples")) ...
    Same as:    y ::=. strquery --first-string "%s" --has apples;
                if (y) ...
</pre>
<p></p>
<pre>    if (!strstr(s, "apples")) ...
    Same as:    y ::=. strquery --first-string "%s" --has apples;
                if (!y) ...
                # Or:
                z ::=. strquery --first-string "%s" --hasno apples;
                if (z) ...
</pre>
<p></p>
<pre>    if (strlen(s) &gt; 10) ...
    Same as:    t ::=. strquery --first-string "%s" --len
                if (t &gt; 10) ...
</pre>
<p></p>
<p>For case-insensitive string operations:</p>
<pre>    if (strcasecmp(s, "apples") &lt; 0) ...
    Same as:    x ::=. strquery --first-string "%s" --insensitive --lt apples;
                # or x ::=. strquery --first-string "%s" --ilt apples;
                if (x) ...
</pre>
<p></p>
<pre>    if (strcasestr(s, "apples")) ...
    Same as:    y ::=. strquery --first-string "%s" --insensitive --has apples;
                # or: y ::=. strquery --first-string "%s" --ihas apples;
                if (y) ...
</pre>
<p></p>
<p>2) Logical string expressions with multiple operators</p>
<pre>    if (strstr(s, "apples") &amp;&amp; strstr(s,"bananas")) ...
    Same as:    x ::=. strquery --first-string "%s" --has-all apples bananas
                if (x) ...
</pre>
<p></p>
<pre>    if (strstr(s, "apples") || strstr(s,"bananas")) ...
    Same as:    y ::=. strquery --first-string "%s" --has-any apples bananas
                if (y) ...
</pre>
<p></p>
<pre>    if (!strstr(s, "apples") &amp;&amp; !strstr(s,"bananas")) ...
    Same as:    z ::=. strquery --first-string "%s" --has-none apples bananas
                if (z) ...
</pre>
<p></p>
<pre>    if (strstr(s, "apples") &amp;&amp; !strstr(s,"bananas") || strlen(s) &gt; 10) ...
    Same as:    t ::=. strquery --first-string "%s" --expression "v1 &amp;&amp; v2 || v3&gt;10" --has apples --hasno bananas --len
                # or t ::=. strquery --first-string "%s" --expression "v1 &amp;&amp; !v2 || v3&gt;10" --has apples --has bananas --len
</pre>
<p></p>
<p>For case-insensitive string operations:</p>
<pre>    if (strcasestr(s, "apples") &amp;&amp; strcasestr(s,"bananas")) ...
    Same as:    x ::=. strquery --first-string "%s" --insensitive --has-all apples bananas
                # or x ::=. strquery --first-string "%s" --ihas-all apples bananas
</pre>
<p></p>
<pre>    if (strcasestr(s, "apples") &amp;&amp; !strcasestr(s,"bananas") || strlen(s) &gt; 10) ...
    Same as:    t ::=. strquery --first-string "%s" --insensitive --expression "v1 &amp;&amp; v2 || v3&gt;10" --has apples --hasno bananas --len
                # or t ::=. strquery --first-string "%s" --iexpression "v1 &amp;&amp; !v2 || v3&gt;10" --ihas apples --ihas bananas --len
                # or t ::=. strquery --first-string "%s" --expression "v1 &amp;&amp; !v2 || v3&gt;10" --ihas apples --ihas bananas --len
</pre>
<p></p>
<p>Note that the --expression query and its case-insensitive counterpart, --iexpression query, are key to building and evaluating a complex arithmetic and/or logical expression. The complex logical expression must be specified immediately after the option. The expression can contain an arbitrary number of operators acting on built-in integer variables v1, v2, v3, etc. If the highest index of the v variables in the expression is n, the command expects n queries to be specified after the expression. These queries are then numbered from 1 to n from left to right, and v&lt;i&gt; is the built-in variable that will store the result of evaluating the i-th query. After strquery executes all the n queries, it will replace the v variables in the expression with their numerical values. The resulting expression is treated as the &lt;expression&gt; argument to the 'calculate' command, i.e., it can contain embedded options as shown in syntax (a1) and (b1) in the 'calculate' man page. The strquery command then calls the 'calculate' library to compute the expression and return the result as the output of the --expression or --iexpression query.</p>
<h3>D5.2. Support for for-loop</h3>
<pre>    for (initial; conditional; update) {
       statement1;
       statement2;
       directives; # such as the following:
       # abort [&lt;message&gt;];       # fail the current mse command with a FAILED status
       # abortall [&lt;message&gt;];    # fail all mse commands on the calling stack with a FAILED status
       # break [&lt;message&gt;];       # get out of the for-loop
       # continue [&lt;message&gt;];    # go back to the 'update' statement
       # done [&lt;message&gt;];        # terminate the current mse command with a SUCCESS status
       # doneall [&lt;message&gt;];     # terminate all mse commands on the calling stack with a SUCCESS status
       statement3;
    }
</pre>
<p></p>
<p>In general, the loop has a numeric counter to control the number of iterations. All initial, conditional, and update expressions have the same syntax as the expression in the 'calculate' command.</p>
<p>All the directives abort, abortall, break, continue, done, done all can accept an optional message to display on the standard output. The message can consist of one or more tokens, each of which will be processed like the arguments to the 'lprints' built-in command.</p>
<p>If the loop counter is a string variable, use the foreach construct as described next.</p>
<h3>D5.3. Support for foreach-loop</h3>
<pre>        foreach [options] variable (list) {
           &lt;body similar to for-loop in above&gt;
        }
</pre>
<p></p>
<pre>        options :== [-d &lt;delimiters&gt;] [-i|-u [-m &lt;maxcount of numbers&gt;]]
</pre>
<p></p>
<p>The foreach construct allows a variable to loop over a list of tokens. By default, the variable is of string data type and the list consists of string tokens (called words) that are separated by white spaces (called delimiters). The default delimiters can be overridden by option -d.</p>
<p>Examples:</p>
<pre>       (a) foreach day (Monday Tuesday Wednesday) { echo %day; }
       (b) foreach -d "/," name (Tom Davis/Mary Gayle,Chris Boyle) { echo %name; }
       (c) foreach x (1 2 5 7 9 11 13 20 25 30 35 40) { echo %x is good; }
</pre>
<p></p>
<p>If the list in (c) is very long, it is more efficient to use a special numeric list where numbers and ranges separated by commas. A range is specified of the form "first-last/stepsize" or "first:last/stepsize". If this format is used, it is required that option -i or -u be specified where option -i is for signed 64-bit integers and option -u for unsigned 64-bit integers.</p>
<p>Thus, (c) is equivalent to the following:</p>
<pre>        (d) foreach -i x (1,2,5-13/2,20-40/5) { echo %x is good; }
</pre>
<p></p>
<p>By default, the list, when fully resolved, is limited to 65536 values to prevent infinite looping (to abort, type CTRL-C or run mse-abort command). If a large limit is desired, use option -m. For example,</p>
<pre>        (e) foreach -i -m 1000000 a (0-3000000/5) { echo %a is multiple of 5; }
</pre>
<p></p>
<p>If option -i is omitted in (d), the list will be interpreted as having a single token and, hence, x becomes a string variable. Thus, the following output will be obtained:</p>
<pre>            1,2,5-13/2,20-40/5 is good
</pre>
<p></p>
<h3>D5.4. Support for while-loop</h3>
<pre>    while (conditional) {
       &lt;body similar to for-loop above&gt;
    }
</pre>
<p></p>
<h3>D5.5. Support for do-while</h3>
<pre>    do {
       &lt;body similar to for-loop above&gt;
    } while (conditional);
</pre>
<p></p>
<p>Curly brackets to enclose the body of the do-loop are highly recommended to ensure correct parsing.</p>
<h3>D5.6. Goto-like directives: break, continue, abort, done, abortall, doneall</h3>
<p>The following directives change the flow of execution. They can be specified with an optional message to display on the standard output. The message can consist of one or more tokens, each of which will be processed like the arguments to the 'lprints' built-in command.</p>
<dl>
<dt><strong>abort [&lt;message&gt;]</strong></dt>
<dd><p>Causes the immediate mse parent command to terminate with a failed status.</p></dd>
<dt><strong>abortall [&lt;message&gt;]</strong></dt>
<dd><p>Causes all the mse commands in the calling stack to terminate with a failed status.</p></dd>
<dt><strong>break [&lt;message&gt;]</strong></dt>
<dd><p>Behaves like the C counterpart in a loop; i.e., exits the immediate loop.</p></dd>
<dt><strong>continue [&lt;message&gt;]</strong></dt>
<dd><p>Behaves like the C counterpart in a loop; i.e., skips the remaining statements in the loop.</p></dd>
<dt><strong>done [&lt;message&gt;]</strong></dt>
<dd><p>Causes the immediate mse parent command to terminate with a success status.</p></dd>
<dt><strong>doneall [&lt;message&gt;]</strong></dt>
<dd><p>Causes all the mse commands in the calling stack to terminate with a success status.</p></dd>
</dl>
<p>Example:</p>
<pre>    for (i = 0; i &lt; 10; i = i+1) {
      if (x%i == -1) {
        break;
      } else if (x%i == 0) {
        abort Failed to compute for i = %i;
      } else {
        # do something
      }
    }
</pre>
<p></p>
<h2>D6. User-Defined Functions</h2>
<p>The &lt;script&gt; can contain zero or more user-defined function definitions. The syntax of a user-defined function definition is as follows:</p>
<pre>    function &lt;function-name&gt; {
       &lt;one or more statements&gt;
    }
</pre>
<p></p>
<p>The name of a function must adhere to the syntax of a variable name that starts with a letter, i.e., it is a string of one or more alphanumeric characters and underscores and the first character must be a letter.</p>
<p>A function can accept zero or more input parameters (or arguments). Argument position 0 is the function name, argument position 1 is the first parameter, etc. The function body can contain positional parameters, which are denoted by &lt;macro-symbol&gt;&lt;position-number&gt;. For example, if the macro symbol is '%', then %0 represents the zeroth argument or function name, %1 the first argument, etc.</p>
<p>When an mse command encounters function definitions in a script, it simply stores them in a master library database without executing them. Once a function is in the database, it can be executed by the built-in "call" command as follows:</p>
<pre>   call &lt;function-name&gt; [&lt;arg1&gt;] [&lt;arg2&gt;] ... [&lt;argN&gt;]
</pre>
<p></p>
<p>When the function is executed, all positional parameters will be expanded. Thus, by default, %0 will expand to &lt;function name&gt;, %1 to &lt;arg1&gt;, %2 to &lt;arg2&gt;, etc. Note that if the k-th argument is not specified, %k will be expanded to an empty string (i.e., removed).</p>
<p>Again, functions must be defined and loaded in memory before it can be used. This can be done by (i) specifying it on the fly before use, or (ii) reading the file that contains the functions using the -L command line option.</p>
<p>If the same function name is defined in multiple files, it must be scoped to avoid ambiguity. To scope a function, specify the base name of the script file followed by two colons and the function name.</p>
<p>For instance, suppose function 'show_users cifs|nfs' is implemented differently in lib1.mse and lib2.mse. To invoke the version in lib1.mse, run the command, say:</p>
<pre>   mse -L lib1.mse:lib2.mse 'call lib1::show_users cifs; &lt;more statements&gt;'
   mse -L lib1.mse -L lib2.mse 'call lib1::show_users cifs; &lt;more statements&gt;'
</pre>
<p></p>
<p>If the function is not scoped, we will get the version that is loaded last. For instance, the following command will invoke the version defined in file2.mse:</p>
<pre>   mse -L lib1.mse:lib2.mse 'call show_users cifs'
</pre>
<p></p>
<p>Note the mse command executes the built-in "call" command by converting it to a nested mse command with a --call option. For instance, the preceding two examples are essentially converted to:</p>
<pre>   mse -L lib1.mse:lib2.mse 'mse --call lib1::show_users cifs'
   mse -L lib1.mse:lib2.mse 'mse --call show_users cifs'
</pre>
<p></p>
<h2>D7. Built-in Variables</h2>
<h3>D7.1. BALI command status</h3>
<p>When a BALI command runs to completion, the mse command will save its status in a number of predefined variables in the minishell environment that is currently in effect. These variables are listed below.</p>
<dl>
<dt><strong>RC</strong></dt>
<dd><p>This variable stores the return code of the BALI command: 10 for success, 11 for syntax error, 12 for execution failure.</p></dd>
<dt><strong>RC_SUCCESS</strong></dt>
<dd><p>This is a boolean variable, which is set to 1 if RC = 10 and 0 otherwise.</p></dd>
<dt><strong>RC_SYNTAX</strong></dt>
<dd><p>This is a boolean variable, which is set to 1 if RC = 11 and 0 otherwise.</p></dd>
<dt><strong>RC_FAILED</strong></dt>
<dd><p>This is a boolean variable, which is set to 1 if RC = 12 and 0 otherwise. Note that RC_FAILED plays the role of the "?$" token in the bash shell.</p></dd>
</dl>
<p>Example:</p>
<pre>    $ mse 'echo Hello'
    Hello
    $ mse-env
    RC=10
    RC_FAILED=0
    RC_SUCCESS=1
    RC_SYNTAX=0
</pre>
<p></p>
<h3>D7.2. Read-only built-in variables</h3>
<p>The following special built-in variables, which start with a period, are supported when the script file or function is specified. For simplicity, this section will refer to both script file and function as script. Note that the period in the name makes it an illegal environment variable name and hence can only be used as a read-only macro.</p>
<dl>
<dt><strong>.argc</strong></dt>
<dd><p>This is the total count of arguments to the script (i.e., script file or function). This count is equal to the number of parameters to the script plus one because the script name is considered the zeroth argument.</p></dd>
<dt><strong>.arg0, .arg1, .arg2, etc</strong></dt>
<dd><p>.arg0 is the name of the script, .arg1 is the first argument to the script, .arg2 is the second argument to the script, etc.</p></dd>
<dt><strong>.argv[n]</strong></dt>
<dd><p>.argv[n] is the n-th argument to the script. If n is specified as a macro, curly brackets should be used to change the order of substitution, e.g., %{.argv[%index]}. Note that the index can be specified as an arithmetic expression.</p></dd>
<dt><strong>.lastarg</strong></dt>
<dd><p>This is the alias for the last argument, i.e., .argv[N] where N+1 is the total number of arguments, including the name of the script.</p></dd>
<dt><strong>.args</strong></dt>
<dd><p>This expands into a string consisting of all arguments starting from 1 where each argument is separated from each other by a single space.</p></dd>
<dt><strong>.dqargs</strong></dt>
<dd><p>This expands into a string consisting of all arguments starting from 1 as follows. Each argument is enclosed by a pair of double quotes and is separated from each other by a single space. The name dqargs stands for double-quoted arguments.</p></dd>
<dt><strong>.sqargs</strong></dt>
<dd><p>This expands into a string consisting of all arguments starting from 1 as follows. Each argument is enclosed by a pair of single quotes and is separated from each other by a single space. The name sqargs stands for single-quoted arguments.</p></dd>
<dt><strong>.cid</strong></dt>
<dd><p>This expands into the mse command id. In general, each running instance of mse is assigned a unique integer id in ascending order starting from 1 after system start up.</p></dd>
<dt><strong>.eid</strong></dt>
<dd><p>This expands into the id of the list of minishell environment variables used by the current mse instance. If two different mse instances have the same eid, they will use the same list of minishell environment variables and hence modifications by one instance will be visible to the other instance.</p></dd>
<dt><strong>.libid</strong></dt>
<dd><p>This expands into the library id of the library used by the current mse instance.</p></dd>
<dd><p>Only the root mse command can create a library; it sets the library id to the same value as its mse command id. Other nested mse commands can only use an existing library. Thus, to make a nested mse command use a particular existing library, one has to specify the --library-id option to the mse command.</p></dd>
<dt><strong>.line, .rawline, .lineno, .__ , .___ , .____ (period followed by 2, 3, or 4 underscores)</strong></dt>
<dd><p>These built-in variables are available when mse is run as a filter only.</p></dd>
<dd><p>If these variables appear in an expression (in a for-loop, arithmetic assignment, etc) or in arguments to built-in functions (strlen, strstr, etc -- see Table 2 of the 'mse-functions' man page), they should be specified without the leading macro symbol and the leading period. In this way the variables will not be evaluated until the expression is actually calculated (see example in section E).</p></dd>
<dd><p>These variables have their values updated whenever the mse filter reads a line from its standard input.</p></dd>
</dl>

<p>a) .__ (period followed by 2 underscores)</p>
<p>This variable represents the input line with the ending newline removed. It expands to an empty string if used in a start-up or exit script.</p>
<p>b) .___ (period followed by 3 underscores)</p>
<p>This variable represents the raw input line (newline preserved). It expands to an empty string if used in a start-up or final script.</p>
<p>c) .____ (period followed by 4 underscores)</p>
<p>This variable represents the line number of the input line. If used in a start-up script, it expands to 0. If used in a final script, it expands to the total number of input lines read by the mse filter.</p>

<dl>
<dt><strong>.line</strong></dt>
<dd><p>This variable and .__ (period followed by 2 underscores) are synonymous.</p></dd>
<dt><strong>.linelen</strong></dt>
<dd><p>This variable stores the length, in bytes, of the input line with the ending newline removed.</p></dd>
<dt><strong>.rawline</strong></dt>
<dd><p>This variable and .___ (period followed by 3 underscores) are synonymous.</p></dd>
<dt><strong>.rawlinelen</strong></dt>
<dd><p>This variable stores the length in bytes of the raw input line.</p></dd>
<dt><strong>.lineno</strong></dt>
<dd><p>This variable and .____ (period followed by 4 underscores) are synonymous.</p></dd>
<dt><strong>.trimmedline</strong></dt>
<dd><p>This variable stores the input line after removing the leading and trailing white space.</p></dd>
<dt><strong>.trimmedlinelen</strong></dt>
<dd><p>This variable stores the length in bytes of the trimmed input line.</p></dd>
</dl>
<p>Example:</p>
<p>Consider the following functions:</p>
<pre>       $ sscat lib1.mse
       function test {
         # Use BALI's echo command
         BALI echo line 1 - %0 %1 %2;
         BALI echo line 2 - %.args;
         BALI echo line 3 - %.dqargs;
         BALI echo line 4 - '%.dqargs';
         BALI echo line 5 - %.sqargs;
         BALI echo line 6 - "%.sqargs";
       }
</pre>
<p></p>
<pre>       # Same function as test but use the built-in echo command
       function test2 {
         echo line 1 - %0 %1 %2;
         echo line 2 - %.args;
         echo line 3 - %.dqargs;
         echo line 4 - '%.dqargs';
         echo line 5 - %.sqargs;
         echo line 6 - "%.sqargs";
       }
</pre>
<p></p>
<p>The following three commands produce the same output:</p>
<pre>       $ mse -L lib1.mse 'call test a b c d'
       $ mse --call lib1::test a b c d
       $ mse -f lib1::test a b c d
</pre>
<p></p>
<pre>       line 1 - test a b
       line 2 - a b c d
       line 3 - a b c d
       line 4 - "a" "b" "c" "d"
       line 5 - a b c d
       line 6 - 'a' 'b' 'c' 'd'
</pre>
<p></p>
<p>The differences between lines 3 and 4 and between 5 and 6 can be explained by noting that once the built-in variables are expanded, mse will send to BALI the following commands:</p>
<pre>       $ echo line 1 - test a b;
       $ echo line 2 - a b c d;
       $ echo line 3 - "a" "b" "c" "d";
       $ echo line 4 - '"a" "b" "c" "d"';
       $ echo line 5 - 'a' 'b' 'c' 'd'
       $ echo line 6 - "'a' 'b' 'c' 'd'"
</pre>
<p></p>
<p>Note the output is different if using the built-in echo command:</p>
<pre>       $ mse -L lib1.mse 'call test2 a b c d'
       line 1 - test2 a b
       line 2 - a b c d
       line 3 - "a" "b" "c" "d"
       line 4 - "a" "b" "c" "d"
       line 5 - 'a' 'b' 'c' 'd'
       line 6 - 'a' 'b' 'c' 'd'
</pre>
<p></p>
<p>Thus, lines 3 and 4 are identical after "-" when the built-in echo command is used.  This can be explained as follows:</p>
<pre>   a) echo line 3 - %.dqargs;
      The built-in echo command sees 4 tokens. The 4th token is %.dqargs
      The built-in echo command does not see any explicit double/single quotes.
      It sees 4 tokens, where the 4th token is %.dqargs. Thus, whatever
      whatever it expands to will be part of the text to display.
</pre>
<p></p>
<pre>   b) echo line 4 - '%.dqargs';
      The built-in echo command sees 4 separate tokens: "line", "4", "-", and
      '%.dqargs'. The pair of single quotes in the last token is to delimit the
      token, and is not part of the token. Thus, the 4-th token is %.dqargs,
      and whatever it expands to will be part of the text to display.
</pre>
<p></p>
<p>Note that the same explanation applies to lines 5 and 6.</p>
<dl>
<dt><strong>.cmdline, .lastcmdline</strong></dt>
<dd><p>When the mse command executes a BALI command, it will save the entire command line in the ".cmdline" built-in variable and the old value of this variable in ".lastcmdline".</p></dd>
<dt><strong>.cmd0, .cmd1, ..., .cmdc, .lastcmd0, .lastcmd1, ..., .lastcmdc</strong></dt>
<dd><p>A command line can consist of multiple simple commands connected with the pipe character (|), the "and" operator (&amp;&amp;), and/or the "or" operator (||). These simple commands are stored in the variables .cmd0, .cmd1, etc in the order of their appearance. The total count of simple commands is stored in .cmdc.  The old values are saved in the same variable names with the ".last" prefix.</p></dd>
<dt><strong>.statement, .laststatement</strong></dt>
<dd><p>When mse executes one of the following statements:</p></dd>
</dl>
<pre>              - Arithmetic assignment statement
              - String assignment statement
              - Command status assignment statement
              - Command output assignment statement
              - Command output and error assignment statement
              - Command line statement
</pre>
<p></p>
<p>it will save the text of the entire statement in the .statement variable. The old value of .statement is saved in .laststatement.</p>
<p>For example, when mse executes the command status assignment statement:</p>
<pre>       rc :== echo abc | strquery --eq abc;
</pre>
<p></p>
<p>it will update the following variables:</p>
<pre>      .statement  : "rc :== echo abc | strquery --eq abc"
      .cmdline    : "echo abc | strquery --eq abc"
      .cmd0       : "echo abc"
      .cmd1       : "strquery --eq abc"
      .cmdc       : 2
</pre>
<p></p>
<p>Note the old values are saved in the similar variables with the ".last" prefix. All the internal built-in variables are stored in the minishell library and can be dumped by the 'mylib' built-in command:</p>
<pre>      $ mse "rc :== echo abc | strquery --eq abc; mylib"
      .cmd0=mylib
      .cmdc=1
      .cmdline=mylib
      .lastcmdc=0
      .lastcmdline== echo abc | strquery --eq abc
      .laststatement=rc :== echo abc | strquery --eq abc
      .statement=mylib
      [cmdid_3].cid=3
      [cmdid_3].eid=140377920597120
      [cmdid_3].fid=0
      [cmdid_3].lid=3
</pre>
<p></p>
<dl>
<dt><strong>.unit_testno, .current_testno, .previous_testno, .next_testno</strong></dt>
<dd><p>These variables are meaningful in the context of unit testing using strquery, which can run as a command or a filter to query its standard input for certain attribute and display the query result.</p></dd>
<dd><p>Option -A, -G, or -W can be specified when the result of strquery is numeric. In this case, strquery will not display the numeric result, but interpret it as a test result and display an appropriate message with statistics about the unit test number, the test completion status (success if test result is positive, failure if zero, and syntax error if negative), the total numbers of tests that succeeded, failed, or errored.</p></dd>
<dd><p>A unit test can begin with the commandline 'strquery --unit-test-begins', and must end with 'strquery -A|-G|-W'. Between these two commandlines are a number of commands that perform the test. These commands are said to run in the context of a unit test, which can be identified with a unit test number. The first test is always number 1.</p></dd>
<dd><p>Consider the following mse script:</p></dd>
</dl>
<pre>          Line 1: &lt;command1&gt;
          Line 2: strquery --unit-test-begins
          Line 3: &lt;command2&gt;
          Line 4: &lt;command3&gt;
          Line 5: &lt;command4&gt; | mse-set output
          Line 6: echo %output | strquery --has Monday -A
          Line 7: &lt;command6&gt;
          Line 8: strquery --unit-test-begins
          Line 9: &lt;command7&gt;
          Line 10: &lt;command7&gt; | strquery --has Tuesday -A
</pre>
<p></p>

<p>This example script has only two unit tests. Test 1 consists of lines 2 to 6, inclusive. Test 2 consists of lines 8 to 10, inclusive.</p>
<p>Use %.current_testno to get the unit test number of the current unit test. This variable is 0 for command1 and command 6 because they do not belong to any unit test. It is 1 for lines 2-6, 2 for lines 8-10.</p>
<p>Use %.last_testno to get the unit test number of the previous unit test. This variable is 0 for lines 1-6, 1 for lines 8-10.</p>
<p>Use %.next_testno to get the unit test number of the next unit test. This variable is 1 for line 1, 2 for lines 1-6, 3 for lines 7-10.</p>
<p>Use %.unit_testno to get the effective unit test number. The effective test number is basically the same as the current test number. But if this value is 0, the command line where this variable is used is assumed to perform setup for the unit test following it, and hence, has an effective test number of that unit test. Thus, command1 has an effective test number 1, and command6 has an effective test number 2.</p>

<h2>D8. Built-in Minishell Commands and Functions</h2>
<p>A built-in minishell command is run as if a BALI command but is actually a function call executed in the mse command context. The following built-in commands are supported.</p>
<h3>D8.1. call</h3>
<p>Syntax:  call &lt;function&gt; [arg1] [arg2] ...</p>
<p>The "call" built-in command is used to execute a user-defined or built-in function or a built-in command.</p>
<p>For example, to execute the "say" function in the test.mse script, one can load the library file first, then invoke call:</p>
<pre>   $ sscat test.mse
   function say {
     echo Hello %1
   }
   $ mse -L test.mse 'call say Tom'
</pre>
<p></p>
<h3>D8.2. Built-in mse::set command to change minishell settings</h3>
<p>The built-in mse::set command displays or changes the internal settings of the minishell currently in use. It can be invoked with an optional leading "call" keyword.</p>
<p>General syntax:</p>
<pre>    mse::set &lt;setting-or-flag&gt;   [&lt;value&gt;]
</pre>
<p></p>
<p>If &lt;value&gt; is not specified, the command displays the current value of the setting. A number of internal flags can be set to 'true' or 'false'. For convenience, the 'false' value can be replaced with 'no', 'disabled', or '0'. Similarly, the 'true' value can be replaced with 'yes', 'enabled', '1', or any nonzero integer.</p>
<p>This built-in command cannot run in the BALI shell. Therefore, it is meaningless, in fact, an error, to specify in the argument list any pipe character ("|") to pipe the output, or "&amp;&amp;" and  "||" to conditionally run another command. However, mse::set can be used in command assignment statements so that its status, output, and error messages can be saved in a variable.</p>
<dl>
<dt><strong>mse::set ignore-syntax-error [true|false|yes|no|1|0]     (default: no)</strong></dt>
<dd><p>A longer name for this setting would be make-syntax-error-non-fatal, but it is not supported. If the value is not specified, the command will display the current value of the flag. Otherwise, the command will change the internal ignore-syntax-error flag dynamically for the current running mse and propagate to all child mse commands; it does not change the flag in the parent mse command.</p></dd>
<dd><p>The flag controls how the mse interpreter copes with syntax errors in commands (Bali commands, mse built-in commands, and mse directives). If the flag is true, the syntax error becomes non fatal; i.e., the interpreter will continue to execute the remaining script instead of aborting itself.</p></dd>
<dd><p>The value of the flag is persistent until mse exits. When mse is started from a Bali console, the default value of the flag is false. When mse is started by another mse, it inherits from the parent mse's flag.</p></dd>
<dd><p>Note that the mse interpreter distinguishes three types of syntax errors and copes with them as described below:</p></dd>
</dl>
<pre>    a. Syntax errors in options to the mse command
         The interpreter aborts itself and exits with failed-on-syntax error code (11)
         This is because errors in options to the mse command are truly syntax errors of mse.
    b. Syntax errors in mse statements or expressions in for-loops, while-loops, if, else if, etc:
         The interpreter aborts itself and exits with failed error code (12)
    c. Syntax errors in commands (Bali commands including mse, mse built-in commands, mse directives):
         The interpreter aborts itself and exits with failed error code (12)
</pre>
<p></p>

<p>Syntax errors (b) and (c) are not really syntax errors of mse; they belong to the relevant mse statements or commands inside the script. If mse should fail with failed-syntax exit code, the Bali shell would automatically display syntax help for mse. This causes confusion because mse was run without any options, or with correct options. Thus, mse must fail with failed exit code 12 for (b) and (c).</p>
<p>mse::set display-summary-on-exit [true|false|yes|no|1|0]     (default: no)</p>
<p>This setting corresponds to option --display-summary-on-exit to the mse command. If set to true, the mse interpreter will execute the built-in command mse::execution-summary to display, just before termination, a report about the execution status of all BALI commands and unit tests, followed by a line summarizing the overall status of the script:</p>

<pre>               Overall script status : SCRIPT PASSED|FAILED
</pre>
<p></p>

<p>The overall status is determined as follows:</p>


<p>a. If the number of mse unit tests is smaller than the minimum-mse-unit-tests-expected setting, the script will display "SCRIPT FAILED".</p>
<p>b. If (a) and (b) do not apply, the script will display "SCRIPT PASSED" if all strquery tests succeeded, and "SCRIPT FAILED" if at least one strquery test failed.</p>

<dl>
<dt><strong>mse::set minimum-mse-unit-tests-expected  [number]        (default: 0)</strong></dt>
<dd><p>This setting is used by the interpeter to handle the setting 'display-summary-on-exit'.</p></dd>
<dd><p>Unit testing is described in the man pages for 'strquery' and 'mse-unit-testing'. Basically, a unit test is a Bali command chain that pipes its output to strquery specified with one of the reporting options -d|-A|-G|-W. The strquery filter can execute a number of operations. By design, the numeric result of the last operation is used to determine the result of the strquery test: positive for success, 0 for failure, and negative for all errors, including syntax errors.</p></dd>
<dd><p>Note that a single Bali command chain with a trailing strquery can produce many results, one per input line to strquery. Thus, the number of strquery results can be greater than the number of unit tests. The setting under discussion refers to the number of unit tests, not strquery results.</p></dd>
</dl>
<pre>       Example:
          $ sscat mytest.scr
          mse::set minimum-strquery-tests-expected 10
          for (i=0; i &lt; 10; i=i+1) {
             . . . . . . .
             sscat file%i.txt | strquery --has 'Friday' -A
          }
</pre>
<p></p>

<p>The script above has 10 strquery tests because the command chain is executed 10 times. The number of strquery results varies depending on the number of lines in each file. If each file has 5 lines, the total number of strquery results displayed is 50.</p>
<p>mse::set maximum-strquery-failed-results-allowed  [number]    (default : 0)</p>
<p>This setting is used by the interpeter to handle the setting 'display-summary-on-exit'. If the number of "TEST FAILED" lines is greater than the specified number, the interpreter will display "SCRIPT FAILED".</p>
<p>mse::set fail-on-undefined-variables [true|false|yes|no|1|0]      (default: true)</p>
<p>By default, mse will fail if it encounters an undefined variable or an undefined macro. This directive allows the user to override the default behavior.</p>
<p>mse::set display-warning-on-undefined-variables [true|false|yes|no|1|0]   (default: true)</p>
<p>If the fail-on-undefined-variables flag is true, mse will fail and display a warning message if it encounters an undefined variable or an undefined macro. This directive allows the user to enable or disable displaying the message.</p>
<p>mse::set verbose [true|false|yes|no|1|0]      (default: no)</p>
<p>The verbose setting corresponds to option --verbose to the mse command. This command changes the verbose flag dynamically and affects all child mse commands. If the value is not specified, the command will display the current value of the flag.</p>
<p>mse::set trace-level &lt;level&gt;    (default: 0)</p>
<p>The trace-level setting corresponds to option --trace-level to the mse command. This command changes the trace level dynamically and affects all child mse commands. If the value is not specified, the command will display the current value of the flag.</p>
<p>mse::set batch-mode [true|false|yes|no|1|0]    (default: false)</p>
<p>The batch-mode setting corresponds to option --batch-mode to the mse command. This command changes the batch-mode flag dynamically and affects all child mse commands. If the value is not specified, the command will display the current value of the flag.</p>
<p>mse::set abort-on-error [true|false|yes|no|1|0]    (default: no)</p>
<p>The abort-on-error setting corresponds to option --abort-on-error to the mse command. This command changes the abort-on-error flag dynamically and affects all child mse commands. Without any argument, the command displays the current value of the abort-on-error flag.</p>
<p>By default, mse does not stop executing the mse script on any failure except syntax error. This is because it already supports flow control keywords for users to handle errors gracefully. However, users can specify the --abort-on-error option to the mse command to alter this behavior; i.e., to abort the mse command whenever a command statement in the script fails.</p>
<p>mse::set escape-char [ &lt;character or character code in hex&gt; ]     (default: @)</p>
<p>The escape-char setting corresponds to option --escape-char to the mse command. This command changes the escape character dynamically and affects all child mse commands. The escape character must be specified as a single character or a hex code between 0 and 255 with prefix 0x or 0X. A value of zero means disable support for escape mechanism. If no character is specified, the command displays the current escape character.</p>
<p>mse::set macro-symbol   [ &lt;character or character code in hex&gt; ]  (default: %)</p>
<p>The macro-symbol setting corresponds to option --macro-symbol char to the mse command. This command changes the macro symbol dynamically and affects all child mse commands. It changes the macro symbol globally, i.e., it is inherited by all child mse commands. The character must be specified as a single character or a hex code between 0 and 255 with prefix 0x or 0X. A value of zero means disable support for macro expansion. If no character is specified, the command displays the current macro symbol.</p>
<p>mse::set enable-quoting-functions [true|false|yes|no|1|0]    (default: false)</p>
<p>This flag controls whether the minishell interpreter supports quoting functions str(), qstr(), dqstr(), esc(), and the math-specific quoting functions mstr(), mqstr(), and mdqstr(). If false, the interpreter treats these functions as literal text. This flag does not control whether the calculator library supports quoting functions. The library always processes them.</p>
<p>mse::set pnode [&lt;pnode number&gt;]      (default:  0)</p>
<p>The pnode setting corresponds to option --pnode to the mse command. This command changes the pnode number dynamically and affects all child mse commands. If the value is not specified, the command will display the current pnode number.</p>

<p>Example: Change escape character dynamically</p>
<pre>  $ mse 'mse::set escape-char'
  @
</pre>
<p></p>
<p>Note the output cannot be piped to another command:</p>
<pre>  $ mse 'mse::set escape-char | wc -l'
  Built-in command does not support "|", "&amp;&amp;", or "||" on command line: mse::set escape-char | wc -l
</pre>
<p></p>
<p>But the output can be captured in a variable using the command assignment syntax:</p>
<pre>  $ mse 'x ::=: mse::set escape-char; echo escape char = %x'
  escape char = @
</pre>
<p></p>
<h3>D8.3. Built-in mse::echo and mse::echo-n functions</h3>
<p>These built-in functions have no options; all arguments are real text to display after all escape sequences and macros are resolved.</p>
<dl>
<dt><strong>mse::echo [argument1] [argument2] [...]</strong></dt>
<dd><p>This built-in function behaves exactly like the BALI 'echo' command without any option. In other words, the output is automatically appended with a newline character.</p></dd>
<dt><strong>mse::echo-n [argument1] [argument2] [...]</strong></dt>
<dd><p>This built-in function behaves exactly like the BALI 'echo -n' command. In other words, the output is not automatically appended with a newline character.</p></dd>
</dl>
<p>Note that although 'mse::echo' and 'echo' have the same behavior, their implementation is different:</p>
<pre>  - 'mse::echo' is truly a function call
  - 'echo' causes mse to spawn a new BALI 'echo' command, hence its output can be piped.
</pre>
<p></p>
<p>The 'mse::echo' version is offered for use in cases where spawning a new command can cause side effects.</p>
<h3>D8.4. Built-in echo command</h3>
<p>Syntax: Same syntax as the Bali version of the 'echo' command</p>
<p>This command behaves like the BALI echo command except that all arguments are resolved in the context of the echo command, not the mse parent command. Unlike the mse::echo built-in function, the built-in 'echo' command can have its output piped to another command.</p>
<p>The following example shows what happens if we force the arguments to be resolved by the parent and the child, respectively:</p>
<pre>   # Resolve in the parent context (i.e., by mse):
   $ mse 'x:=Serial #: 156; RPC echo Laptop: %x'
   Laptop: Serial
</pre>
<p></p>
<pre>   # Resolve in the child context (i.e., by echo):
   $ mse 'x:=Serial #: 156; RCC echo Laptop: %x'
   Laptop: Serial #: 156
</pre>
<p></p>
<p>For this reason the 'echo' command is treated as a built-in command when it is run by the mse command. In other words, there is no need to specify the RCC keyword when we want 'echo' to resolve its arguments:</p>
<pre>   # Built-in command
   $ mse 'x:=Serial #: 156; echo Laptop: %x'
   Laptop: Serial #: 156
</pre>
<p></p>
<h3>D8.5. BALI, RCC, RPC keywords</h3>
<p>Syntax:</p>
<pre>         BALI &lt;bali-command-name&gt;   [arg1] [arg2] ...
         RCC  &lt;bali-command-name&gt;   [arg1] [arg2] ...
         RPC  &lt;bali-command-name&gt;   [arg1] [arg2] ...
         RCC/&lt;instruction&gt; &lt;bali-command-name&gt; [arg1] [arg2] ...
         RPC/&lt;instruction&gt; &lt;bali-command-name&gt; [arg1] [arg2] ...
</pre>
<p></p>
<p>a) The "BALI" keyword is used to tell mse to run a BALI command. Normally, this is unnecessary. But if an mse built-in command has the same name as the BALI command (e.g. echo), invoking the BALI keyword is the only way to ensure the BALI version of the command is executed.</p>
<p>Example:</p>
<pre>   mse 'BALI echo Hello'  # run BALI's echo command
   mse 'echo Hello'       # run mse's built-in echo command
</pre>
<p></p>
<p>The "BALI" keyword also causes the mse command not to pass its settings/options to the child command immediately following the keyword. See examples (d) and (e) in section C8.3.1. This feature can be used to run any mse command inside a script where the second mse needs to behave like an independent mse instance, not like a child mse.</p>
<p>Example:</p>
<pre>   $ sscat bigscript.scr
   . . . . . . . . .
   . . . . . . . . .
   mse -f mytest.scr          # (1)
   . . . . . . . . .
   BALI mse -f mytest1.scr    # (2)
   . . . . . . . . .
</pre>
<p></p>
<pre>   $ mse -f bigscript.scr     # (3)
</pre>
<p></p>
<p>In this example, the mse instance (3) is the parent command, which runs all commands in the script:</p>
<pre>  - the mse command in (2) will be treated as a child mse, which inherits settings from the mse parent.
  - the mse command in (3) will be treated as independent, hence, it inherits no settings from the mse parent.
</pre>
<p></p>
<p>b) The RCC keyword stands for "Resolve in Child's Context". It tells mse to run the specified child's command line as is and let the child resolve all the macros and escape sequences in its arguments by itself. This is described in section A3.2.</p>
<p>c) The RPC keyword stands for "Resolve in Parent's Context". It tells mse to resolve all the macros and escape sequences in the child's command line before running it. This is described in section A3.3.</p>
<p>d) Optional instruction</p>
<p>Both the RPC and RCC keywords can be optionally followed by a forward slash delimiter, which, in turn, is followed by an instruction string that tells how to resolve the command line. The delimiter can be replaced with a colon or a dot. The instruction string contains a sequence of one or more characters, each of which tells what to do in each pass. The characters are the same as those defined for the --preprocess-sequence option, i.e.,</p>
<pre>           e : to resolve only escape sequences in one pass
           m : to resolve only macros in one pass
           b : to resolve both escape sequences and macros simultaneously in one pass
           0 : (zero) to not resolve, leave the command line as is
</pre>
<p></p>
<p>For example,</p>

<p>* RCC/e means to let the child command scan the command line in one pass and resolve only escape sequences</p>
<p>* RCC/e means to let the child command scan the command line in two passes and resolve only escape sequences in each pass.</p>
<p>* RCC/eeb means to let the child command scan the command line in three passes: resolve only escape sequences in the first two passes, and then resolve only macros in the third pass.</p>

<p>Example:</p>
<pre>   # Note @c is '@', and @A is '&amp;':
   $ mse 'echo @cA'
   @A
   $ mse 'RCC/ee echo @cA'
   &amp;
</pre>
<p></p>
<h3>D8.6. Built-in commands to get/set variables:</h3>
<p>To list, set, unset variables in the minishell environment:</p>
<pre>     (a1) myenv [--verbose] [--name &lt;name&gt;]
     (b1) myenv-set [--verbose] [--init-only] [--update-only] &lt;name&gt; &lt;value&gt;
     (c1) myenv-unset &lt;name&gt;
</pre>
<p></p>
<p>To list variables in the minishell library:</p>
<pre>     (d1) mylib [--verbose] [--name &lt;name&gt;]
</pre>
<p></p>
<p>The syntax of these built-in commands is identical to the BALI commands: mse-env, mse-set, and mse-unset. The only difference is that the myenv and mylib versions access the variables in the minishell environment currently used by the running mse instance. If the minishell is local or inherited, the variables will be gone when the topmost-level mse command terminates.</p>
<p>Example:</p>
<pre>  $ mse-unset x                              # x no longer in the global MSEV
  $ mse-env --name x
  Undefined variable name: x
  $ mse --local 'x=5; myenv --name x'        # x is set in the local MSEV, not global MSEV
  x=5
  $ mse-env --name x                         # x not in the global MSEV
  Undefined variable name: x
  $ mse-set -v x 7                           # set x in the global MSEV
  x=7
  $ mse --local 'x=5; myenv-unset x; myenv --name x'
  Undefined variable name: x
  $ mse-env --name x
  x=7
</pre>
<p></p>
<p>Note that the myenv/mylib command family can be used in command substitution:</p>
<pre>   $ echo abc | strquery -m % --length --echo "Env: %(myenv) @n Library: %(mylib)"
</pre>
<p></p>
<h3>D8.7. Built-in abort and done directives</h3>
<p>The bash shell supports 'exit n' where n is the exit code of the shell. This functionality is supported in mse in the form of two distinct built-in commands, 'done' and 'abort', to avoid conflicts with the existing 'exit' command in BALI. The 'done' command causes the mse command to exit with exit code 10 for success, and 'abort' with exit code 12 for failure. These values are the standard BALI command exit codes (see section D7.1).</p>
<p>Basically, 'done' is equivalent to the bash command 'exit 0', and 'abort' to 'exit n' where n is nonzero. These two built-in commands cause the current 'mse' command to terminate immediately.</p>
<p>Note the commands can accept an optional message to display on the standard output. The message can consist of one or more tokens, each of which will be processed like the arguments to the 'lprints' built-in command.</p>
<h3>D8.8. Built-in abortall and doneall directives</h3>
<p>These two built-in directives cause all the mse commands on the calling stack up to the topmost-level parent mse in context to terminate with exit code 12 for 'abortall', and 10 for 'doneall'. The commands can accept an optional message to display on the standard output. The message can consist of one or more tokens, each of which will be processed like the arguments to the 'lprints' built-in command.</p>
<p>Example 1:</p>
<pre>    $ mse -n -f test-abortall.mse               # first mse command, as denoted mse1
</pre>
<p></p>
<pre>    $ sscat example.mse
    mse-set PATH A
    echo PATH = %PATH
    rc ::= ssrun -c "
              mse -m / '                        # second mse, denoted as mse2
              for (i=0; i&lt;10; i=i+1) {
                 echo -n start i=/i --;
                 if (i&gt;1) {
                    mse-set PATH /{PATH}B
                    mse doneall;                # third mse, denoted as mse3
                    mse-set PATH /{PATH}C
                 }
                 echo end i=/i;
             }';
             mse  'echo sibling mse command'    # fourth mse, denoted as mse3
             mse-run -m / mse-set PATH  '/{PATH}D'
          ";
</pre>
<p></p>
<pre>    echo PATH=%PATH, rc=%rc;
</pre>
<p></p>
<p>Output:</p>
<pre>    start i=0 --end i=0
    start i=1 --end i=1
    start i=2 --sibling mse command
    PATH=AB, rc=10
</pre>
<p></p>
<p>Explanation:</p>
<pre>   - There are 4 mse commands involved when running 'mse -n -f test-abortall.mse'.
   - Calling stack (without considering the actual execution logic):
</pre>
<p></p>
<pre>                      mse1
                       |
                     ssrun
                    /     \
                  mse2    mse4
                   |
                  mse3
                   |
                 doneall
</pre>
<p></p>
<pre>   - The topmost-level mse command for 'doneall' is 'mse2' because ssrun does not
     support minishell,
   - Thus when 'doneall' is executed, all the mse commands in the calling path
     will exit with exit code 10, one after another: first mse3, then mse2.
   - When control reaches ssrun, it will then execute mse4.
</pre>
<p></p>
<p>Example 2:</p>
<p>If we replace the token "ssrun -c" in Example 1 with "mse", the topmost-level mse command will be mse1. Thus, when 'doneall' is executed, all mse instances will exit, including mse1, which will not execute the statement:</p>
<pre>    echo PATH=%PATH, rc = %rc;
</pre>
<p></p>
<p>Thus, the output will be as follows:</p>
<pre>    start i=0 --end i=0
    start i=1 --end i=1
    start i=2 --
</pre>
<p></p>
<p>Example 3:</p>
<p>If we replace 'doneall' with 'abortall' in Example 1, the output will be unchanged because rc is still 10 (success), not 12 (failure). This is because ssrun continues to executes these two lines after mse2 is aborted:</p>
<pre>             mse  'echo sibling mse command'    # fourth mse, denoted as mse3
             mse-run -m / mse-set PATH  '/{PATH}D'
</pre>
<p></p>
<p>The last command, mse-run, runs successfully. Its exit code is then ssrun's exit code.</p>
<h3>D8.9. Built-in functions print, prints, lprint, lprints</h3>
<p>The s suffix means adding a space between tokens to print. The l prefix means print a line, i.e., adding a newline after the last token.</p>
<p>These built-in functions have a command-like syntax and, hence, their output can be assigned to a variable using the command output assignment operators described in sections D4.4 to D4.5. The funtions treat each argument as a numeric or string expression, evaluate it using the same library as the 'calculate' command, and finally display the result.</p>
<p>The print and lprint functions display the results of all arguments, one after another without any intervening spaces. The prints and lprints functions display all the results with an intervening space in between. The lprint and lprints functions add a newline character at the end of the last result.</p>
<p>Note that the arguments to these printing functions are processed as follows.</p>
<p>* The characters &amp; and | are considered literal text for parsing purposes.</p>
<p>* If an argument is enclosed by a pair of double or single quotes, it is treated as text with the enclosing quotes discarded. The printing function then resolves all escapes and macros in the text.</p>
<p>* If an argument is a macro of the form %(commandline), it will be identified as a command substitution. The command line consists of all space-delimited tokens between the two parentheses. The printing function resolves all escapes and macros in the command line and then executes it.  The result is treated as text.</p>
<p>* If an argument is a macro of the form %((expression)), it will be identified as an arithmetic expansion. The arithmetic expression consists of all space-delimited tokens between the pair of double parentheses. The printing function resolves all escapes and macros in the expression and then executes it using the calculate command library.  The result is treated as text.</p>
<p>* Otherwise, the argument is parsed as if it were an expression to the calculate command. The printing function resolves all escapes and macros in the expression, and then executes it using the calculate command library.  The result is treated as text.</p>
<p>Note that a mathematical expression can contain sub-expressions enclosed in parentheses, and/or functions with the arguments listed between a pair of parentheses. Thus, if the parser encounters an unquoted left parenthesis, it will continue until it finds a matching unquoted right parenthesis. In this case, any space encountered during the search is part of the expression. Once the match is found, the parser continues until reaching a subsequent space or the end of the last argument.</p>
<p>For example, the mathematical expression x + 5*y can be specified as follows</p>
<pre>      a) x+5*y
      b) (x + 5 * y)
      c) %((x + 5 * y))
</pre>
<p></p>
<p>All the three cases are parsed as a single command line token.</p>
<p>Example:</p>
<pre>   $ sscat test.scr
   x = 10;
   y = 3
   lprints "The result of x+y is" x+y              # (1)
   lprints str(The result of x-y is) (x - y)       # (2)
   t ::=: prints "x*y is" x*y                      # (3)
   echo Result: %t                                 # (4)
   lprints "It" strstr("Hello there", "t")         # (5)
   lprints str/x/abc(){}[]{} / | ! #&lt;&gt;;'"&amp;$/x/;
</pre>
<p></p>
<pre>   $ mse -f test.scr
   The result of x+y is 13
   The result of x-y is 7
   Result: x*y is 30
   Hi there
   abc(){}[]{} / | ! #&lt;&gt;;'"&amp;$
</pre>
<p></p>
<p>Explanation:</p>
<pre>  (1): argument 2 is [x+y], which is an expression.
       The square brackets are used to delimit the string and are not part of the argument.
  (2): argument 2 is [(x - y)], which is an expression.
       The parser does not stop parsing until it finds the matching closing right parenthesis.
  (3): no display, the function output is assigned to variable t.
  (5): argument 2 is [strstr("Hello there", "t")], which is an expression.
       The parser does not stop parsing until it finds the matching closing right parenthesis.
</pre>
<p></p>
<p>Note str() is a quoting function, which plays the role of a pair of quotes to delimit a string. All characters enclosed by str() are literal except the escape character (default is '@') and the macro symbol (default is '%'). The delimiting parentheses can be replaced with {}, [], or &lt;&gt;. They can also be replaced with a pair of identical delimiting tags of the form /somestring/. In example (6) above, the delimiting tag is "/x/".</p>
<h3>D8.10. Built-in mse::execution-summary command</h3>
<p>This built-in command can be specified at the end of an mse script to get a summary of the execution. It will report the status of execution: number of BALI command lines executed, failures, etc. It also includes a special report on strquery as described below. Note that the execution summary can also be produced upon exit if mse is run with -Y option or the mse script has the --display-summary-on-exit flag enabled before exit:</p>
<pre>      call mse::set display-summary-on-exit true
</pre>
<p></p>
<h3>Unit test report</h3>
<p>The strquery filter can query a variety of properties of the output from the preceding command in the chain. For instance,</p>
<pre>     $ echo abc def xyz | strquery --has xyz
     1
</pre>
<p></p>
<p>One can turn the query result in to a test report by specifying one of the reporting flags -A|-G|-W|-d. For instance,</p>
<pre>     $ echo abc def xyz | strquery --has xyz -d
     TEST PASSED
</pre>
<p></p>
<p>When such a reporting option is specified to strquery, the entire command line is called a unit test and strquery will maintain some global counters to record the number of the tests and the counts of success/failure/error statuses.</p>
<p>If the preceding command in the chain fails (e.g., echo) and does not pass any output to strquery, the ending strquery filter will not be called to execute. Therefore, the statistics of the current unit test is not recorded in strquery's global counters.</p>
<p>If the command line above is in an mse script, the mse interpreter is responsible for executing the command line and keeping track of the execution status.  Thus, mse knows that (i) it has attempted to execute the command line, and (ii) the command line failed to execute. For this reason, the built-in mse::execution-report command can report statistics for unit tests more accurately than strquery.</p>
<h3>Execution summary</h3>
<p>A typical summary looks as follows.</p>
<pre>           $ sscat mytest.scr
           . . . . . . . . . . .
           . . . . . . . . . . .
           mse::execution-summary
</pre>
<p></p>
<pre>    Line   $ mse -f mytest.scr
     1     SCRIPT EXECUTION SUMMARY:
     2        [mse] Total BALI command lines executed : 160
     3           Succeeded        : 158
     4           Failed           : 2
     5           Syntax errors    : 0
     6        [mse] Total unit tests executed : 33 (from commands piped to 'strquery -A|-G|-W', unit tests numbered)
     7           Succeeded        : 32
     8           Failed           : 1
     9           Syntax errors    : 0
    10        Compare unit tests reported by mse and strquery:
    11                [mse] Total : 33 ( passed = 32, failed = 1, errored = 0 )
    12           [strquery] Total : 33 ( passed = 33, failed = 0, errored = 0 )
    13
    14        Inconsistencies detected:
    15               False errors : 1 unit tests passed based on criteria specified in strquery,
    16                              but mse counted as failed because it relied on command status returned to BALI
    17
    18        Overall unit test status : SCRIPT PASSED
</pre>
<p></p>
<p>Explanation:</p>
<p>* Line 2 reports the total number of BALI command lines executed. Note that (i) mse built-in commands and functions are not included, and (ii) the number of command lines is not the same as the number of commands. A command line can contain more than one command; e.g.,</p>
<pre>       $ echo List of files %(ls -l)                        # 1 command line with 2 commands
       $ echo abc def | strtoken %[1] | strquery --has abc  # 1 command line with 3 commands
</pre>
<p></p>
<p>* Lines 3, 4, 5 are the breakdown of line 2.</p>
<p>* Line 6 reports the number of unit tests that mse ran. Note a unit test is a chain of commands that pipes the output to the last strquery in the chain. The ending strquery processes the input subject based on pass/fail/error criteria along with an option -A|-G|-W|-d to display the statistics.</p>
<p>* Lines 7, 8, 9 are the breakdown of line 6.</p>
<p>* LInes 11 and 12 list the statistics computed by mse and strquery independently.</p>
<p>* Lines 14 and following explain unsual observations. This line is shown only when there is some problem.</p>
<p>The example above contains the following test:</p>
<pre>      $ mse-unset COUNT
      $ backquote --capture-stder -- mse-env --name COUNT | strquery --has 'Undefined variable name: COUNT' -A -E
</pre>
<p></p>
<p>Basically, the COUNT variable is unset and hence any attempt to display it will result in an error message. To verify this behavior of mse-env, we need to pass the error message to strquery. Because only the standard output can be piped to strquery, we need to have backquote run mse-env so that it can capture all standard error messages to the standard output.</p>
<p>But backquote is designed to return the same exit code to the shell as the target command that it runs. In this example, mse-env failed, and hence backquote failed. This failure was captured by mse, which reported in line 8.</p>
<p>However, strquery was able to read and process the input. It then concluded the unit test PASSED based on the pass/fail/error conditional.</p>
<p>Thus, as far as unit testing is concerned, the failure reported in line 8 is a false error.</p>
<p>* Line 18: Final overall status of the script.</p>
<p>This status is based on the unit tests; i.e., failures in commands that do not belong to unit test command lines are not counted.</p>
<h3>Where is the execution summary stored?</h3>
<p>The execution summary is saved in a number of variables in the global minishell environment. The variables will be updated whenever mse executes a BALI command. Thus, it is necessary to remove them (e.g., run mse-unset --all). before starting an mse script. Otherwise, the statistics will include tests from the previous mse runs.</p>
<p>Note that the execution summary does not include statistics from mse built-in commands or functions. Therefore, the summary remains unchanged until one clears the environment variables, or runs an mse script that contains BALI commands.</p>
<p>If we simply run an mse script that has no BALI commands, the old summary does not change. For example, we can run the following script at any time</p>
<pre>     $ mse mse::execution-summary
</pre>
<p></p>
<p>to get the execution summary of the most recent run of an mse script that has BALI commands.</p>
<h3>D8.11. Built-in mse hooks</h3>
<p>An mse hook is a function with a predefined name that the mse interpreter calls at specific point in its life. The following mse hooks are currently supported with an empty body:</p>
<pre>   1. function on_preprocessing {}
      The interpreter executes this function immediately before the preprocessing phase.
      The preprocessing phase occurs immediately after all the mse command line options are parsed
      successfully, and all the libraries and the script body are loaded successfully.
</pre>
<p></p>
<pre>   2. function on_running_script {}
      The interpreter executes this function immediately after the preprocessing phase is completed
      and before the running phase.  In the running phase, mse parses the script body to get one statement
      at a time and execute it on the fly.  In other words, parsing and executing occur at the statement
      level, not script level. Thus, there is no support for on_parsing{} and on_executing{} for the script.
      This function is overridden by the command-line option --startup-script.
</pre>
<p></p>
<pre>   3. function on_displaying_execution_summary {}
      The interpreter executes this function just before processing the execution summary, if any.
</pre>
<p></p>
<pre>   4. function on_exit {}
      The interpreter executes this function just before termination.
      This function is overridden by the command-line option --exit-script.
</pre>
<p></p>
<p>Users can override the behavior of these hooks by supplying their own versions with the same names. For example,</p>
<pre>      function on_running_script {
         echo Hello there;
      }
      function on_exit {
         echo Bye;
      }
</pre>
<p></p>
<h2>D9. Built-in Math and String Functions</h2>
<p>All assignments, conditionals, as well as initials and updates in the for-loop are validated and evaluated by the same library used by the 'calculate' command. Therefore, the mse script can use all the built-in functions that are available to the 'calculate' command. All values of variables and function returns are considered string or numeric depending on the context.</p>
<p>For a complete list of built-in functions, see the 'mse-functions' man page.</p>
<p>Example:</p>
<pre>   $ sscat test.mse
   x=strlen("abc")+abs(-4);        # similar to: calculate 'x=strlen("abc")+abs(-4)'
   y=strstr("Hello there", "t");   # y="there"
   z=strstr("Hello there", "abc"); # z is an empty string
   a=123456;
   t=strstr(a, "4");     # t is "456"
   if (strlen(a) == 6) echo Good;'
   b:="count";
   for(i=0; i&lt;strlen(a); i=i+1) {
     c=char(a,i);
     b:="%b %c";
     echo %b;
   }'
</pre>
<p></p>
<h2>D10. Functions to query script arguments</h2>
<p>Section 14 of Table 2 in the 'mse-functions' man page describes all functions available to process the arguments to an mse script.</p>
<p>As an example, let create-user.scr be an mse script that will create a local user given the name, uid, and gid. The script can be designed to run as follows:</p>
<pre>   $ mse -f create-user.scr --name test  --passwd testpw --level user
               |               |    |       |      |      |     |
            argument0         arg1 arg2    arg3   arg4   arg5  arg6
</pre>
<p></p>
<p>If fully specified as above, the script has a total of 7 arguments, where the zeroth argument is the name of the script.</p>
<p>The following functions are available for use in the script to query the specified arguments at runtime:</p>
<dl>
<dt><strong>argc()</strong></dt>
<dd><p>Return the number of arguments to the script (e.g. 7 in example above).</p></dd>
<dt><strong>argv(n)</strong></dt>
<dd><p>Return the n-th argument to the script.</p></dd>
<dd><p>For example, argv(0) returns "create-user.scr", argv(1) returns "--name".</p></dd>
<dt><strong>has_option(s)</strong></dt>
<dd><p>Return the index of option s in the script argument list, or 0 if option s is not specified. Note s can be partially specified as long as the match is unique.</p></dd>
<dd><p>For instance, has_option("--passwd") returns 4. So do has_option("--p") and has_option("--pa"), etc.</p></dd>
<dt><strong>get_optionvalue(s)</strong></dt>
<dd><p>Return the value of option s in the script argument list. The function fails if option s is not specified. For this reason, the function is often used to process mandatory options.</p></dd>
<dd><p>For instance, get_optionvalue("--passwd") returns "testpw".</p></dd>
<dt><strong>get_optionvalue(s,t)</strong></dt>
<dd><p>This function always succeeds. If option s is specified in the command line, the function returns the value of option s. Otherwise, it will return the default value t, which is supplied by the caller.</p></dd>
<dd><p>For example, get_optionvalue("--home","/home/hoc") returns "/home/hoc" because the --home option is not specified.</p></dd>
</dl>
<p>Example:</p>
<pre>  $ sscat create-user.scr
  user = get_optionvalue("--user");
  pw = get_optionvalue("--password");
  level = get_optionvalue("--level", "user");
  user add %user %ps %level
</pre>
<p></p>
<pre>  $ mse -f create-user.scr hoc hoc2016
</pre>
<p></p>
<h2>D11. How to specify a literal string in an mse script?</h2>
<p>How to specify a literal string has been described at various places in this man page. The goal of this section is to provide a summary of examples for reference. Note that the examples are statements that work only when they appear in an mse script.</p>
<h3>D11.1. Use double or single quotes</h3>
<pre>     * Assignment using arithmetic assignment operator "="
          title = "Annual Report";
          title = 'Annual Report';
</pre>
<p></p>
<pre>     * Assignment using string assignment operator ":="
          title := "Annual Report";
          title := 'Annual Report';
          title :=Annual Report;
</pre>
<p></p>
<pre>     * Built-in function print
          print "What's up?"
          print He says: "What's" up?
</pre>
<p></p>
<pre>     * Bali command line arguments:
          ls -l "my report";
          ls -l 'my report';
          calculate 'x="Hello"'
          ssrun -c "ls -l file1; rm file1"
          ssrun -c 'ls -l file1; rm file1'
</pre>
<p></p>
<h3>D11.2. Use quoting functions</h3>
<p>There are for quoting functions: str(), qstr(), dqstr(), and esc(). However, they are normally treated as normal text unless they appear in the following cases:</p>
<pre>     * Assignment using arithmetic assignment operator "="
          title = str(What's up?);
          title = str[What's up?];
          title = str&lt;What's up?&gt;;
          title = str{What's up?};
          title = str/xx/What's up?/xx/;
</pre>
<p></p>
<pre>     * Arguments to BALI commands or built-in commands or built-in functions
          ls str(Friday's report)    # file name: "Friday's report"
          ls "str(Friday's report)"  # str becomes normal, file name: "str(Friday's report)"
          print str(Technology in the 1980's);
          calculate x=str(New Year's Day);
</pre>
<p></p>
<p>See details in section C4.4.</p>
<h3>D11.3. Use verbatim escape sequences</h3>
<p>For more information in Table 4 of 'quoted-text' man page. The following examples are based on '@' as the default escape character:</p>
<pre>     * Assignment using arithmetic assignment operator "="
          title = @W(What's up?@W);
          title = @w(What's up?@w);
</pre>
<p></p>
<pre>     * Assignment using string assignment operator ":="
          title := @W(What's up?@W);
          title := @w(What's up?@w);
</pre>
<p></p>
<pre>     * Built-in function print
          print @W(What's up?@W)
          print He says: @W(What's up?@W)
</pre>
<p></p>
<pre>     * Bali command line arguments:
          ls -l @W(my report@W);
          ls -l @w(my report@w);
          calculate 'x=@W(Hello@W)'
          calculate 'x=@w(Hello@w)'
          ssrun -c @W(ls -l file1; rm file1@W)
          ssrun -c @w(ls -l file1; rm file1@w)
</pre>
<p></p>
<pre>     Note that one can temporarily turn off the escape character interpretation
     by setting the escape character to NUL as follows:
</pre>
<p></p>
<pre>          mse::set escape-char 0x00   # disable escape mechanism
          echo @w(my report@w);       # display as is: @w(my report@w)
          mse::set escape-char @      # restore default escape character
</pre>
<p></p>
<h2>E. Filter</h2>
<p>When run as a filter, mse supports all options described in section B except --eof, plus the two filter-specific options --startup-script and --exit-script. In addition, it makes available the following dynamic built-in variables (see section D7.2 for a complete description):</p>
<pre>  a) .____ (period followed by 4 underscores):  line number of the input line
  b) .___ (period followed by 3 underscores): raw input line (newline not removed)
  c) .__ (period followed by 2 underscores): cooked input line (with newline removed)
</pre>
<p></p>
<p>The standard input to the filter can be resolved during the preprocessing phase by using the %% preprocessor token. This is especially helpful if the input is an mse script.  For instance,</p>
<pre>  $ sscat filter.scr
  echo Hello there
  echo How are you?
</pre>
<p></p>
<pre>  $ sscat filter.scr | mse '%%.__'
</pre>
<p></p>
<p>This results in the mse filter executing the multiple scripts, one at a time:</p>
<pre>  $ mse 'echo Hello there'
  $ mse 'echo How are you?'
</pre>
<p></p>
<p>When run as a filter, mse can be used to transform any BALI command to a filter. For example, to run the "ls &lt;filename&gt;" command on a list of files stored in mylist.txt:</p>
<pre>  $ cat mylist.txt | mse 'ls %.__'
</pre>
<p></p>
<p>If these variables are used in an expression (for-loop, assignment, string/math functions, etc) they should be specified without the leading token "%." so that the variables will be evaluated only when the expression is computed. For instance,</p>
<pre>  $ echo "Hello Tom" | mse 'len = strlen(__); echo len = %len;'
  len = 9
</pre>
<p></p>
<pre>  $ echo "Hello Tom" | mse -A 'len = strlen(%.__); echo len = %n;'
</pre>
<p></p>
<p>The last example fails. After the mse filter parses the first statement, it sees "len = strlen(Hello Tom);". This causes the strlen function to fail when it parses the passed in argument.</p>
<h1>Examples</h1>
<p>1. Create 100 files</p>
<pre>   $ mse 'vn 1; mount -o fs1; cv fs1; for (i=0; i&lt;100; i=i+1) { touch file%i; }'
</pre>
<p></p>
<p>It is possible to run the command above without quoting as follows:</p>
<pre>   # Use ".," as command separator
   $ mse -D [  -C ., vn 1., mount -o fs1., cv fs1., for (i=0., i&lt;100., i=i+1) [ touch file%i., ]
</pre>
<p></p>
<pre>   # Use "," as command separator
   $ mse -D [  -C , vn 1, mount -o fs1, cv fs1, for (i=0, i&lt;100, i=i+1) [ touch file%i, ]
</pre>
<p></p>
<p>Because all algebraic/logical expressions follow the syntax of the 'calculate' command, we can use the mnemonic operators, such as ".lt." for "&lt;":</p>
<pre>   $ mse -D [  -C , vn 1, mount -o fs1, cv fs1, for (i=0, i .lt. 100, i=i+1) [ touch file%i, ]
</pre>
<p></p>
<p>The general parsing rule is that the first token that is not an option (e.g., token "vn" in the example above) is the start of the mse script. The complete script is formed by concatening all subsequent tokens together with a single space in between. For example, the complete mse script of the preceding command is as follows:</p>
<pre>   "vn 1, mount -o fs1, cv fs1, for (i=0, i .lt. 100, i=i+1) [ touch file%i, ]"
</pre>
<p></p>
<p>Note that the script above logs 100 instances of the "touch" command in dblog. To avoid command line logging, run mse with --batch-mode option. Note that the command output and error are still logged. Compare the dblog for the two commands below:</p>
<pre>   a) Without --batch-mode
      $ mse 'for (i=0; i &lt; 100; i=i+1) { echo file%i; }'
      2015-03-21 19:14:28.979-07:00 HNAS-4060 mercury2m3-a[mercury2m3-s]:$ &lt;no newline&gt;
      2015-03-21 19:15:56.054-07:00 HNAS-4060 mse 'for (i=0; i &lt; 100; i=i+1) { echo file%i; }'
      2015-03-21 19:15:56.874-07:00 HNAS-4060 User action: MMB1 local mse 'for (i=0; i &lt; 100; i=i+1) { echo file%i; }'
      2015-03-21 19:15:56.874-07:00 HNAS-4060 User action: MMB1 local echo file0
      2015-03-21 19:15:56.875-07:00 HNAS-4060 file0
      2015-03-21 19:15:56.875-07:00 HNAS-4060 User action: MMB1 local echo file1
      2015-03-21 19:15:56.875-07:00 HNAS-4060 file1
      . . . . . . . .
      2015-03-21 19:15:56.892-07:00 HNAS-4060 file98
      2015-03-21 19:15:56.893-07:00 HNAS-4060 User action: MMB1 local echo file99
      2015-03-21 19:15:56.893-07:00 HNAS-4060 file99
</pre>
<p></p>
<pre>   b) With --batch-mode
      $ mse -b 'for (i=0; i &lt; 100; i=i+1) { echo file%i; }'
      2015-03-21 19:16:57.274-07:00 HNAS-4060 mercury2m3-a[mercury2m3-s]:$ &lt;no newline&gt;
      2015-03-21 19:17:16.525-07:00 HNAS-4060 mse -b 'for (i=0; i &lt; 100; i=i+1) { echo file%i; }
      2015-03-21 19:17:17.300-07:00 HNAS-4060 User action: MMB1 local mse -b 'for (i=0; i &lt; 100; i=i+1) { echo file%i; }'
      2015-03-21 19:17:17.300-07:00 HNAS-4060 file0
      2015-03-21 19:17:17.301-07:00 HNAS-4060 file1
      . . . . . . . .
      2015-03-21 19:17:17.324-07:00 HNAS-4060 file98
      2015-03-21 19:17:17.324-07:00 HNAS-4060 file99
</pre>
<p></p>
<p>2. Suppose we used to use the ssrun command to run a script, say test.scr.  We can now run it with the mse command as follows:</p>
<pre>   $ mse --file test.scr
</pre>
<p></p>
<p>The main advantage is that mse can support escapes and macros. Note that mse will append a semicolon at the end of each command line in files with ".scr" extension.</p>
<p>For files with .mse extension, the mse command with -n option will smartly append a semicolon if and only if the lines should be, but are not, terminated with a semicolon.</p>
<pre>   $ mse -n --file test2.mse
</pre>
<p></p>
<p>A few useful commands to manage files in flash:</p>
<pre>   a) To transfer a file, say example.mse, from a Linux system to flash on server:
</pre>
<p></p>
<pre>      $ ssc &lt;server name&gt; ssput example.mse /example.mse
</pre>
<p></p>
<pre>   b) Display the content of a file from flash:
</pre>
<p></p>
<pre>      $ sscat example.mse
</pre>
<p></p>
<pre>   c) List all mse scripts from flash
</pre>
<p></p>
<pre>      $ ssls | grep .mse | sort
</pre>
<p></p>
<p>3. To dump the script mentioned in section D1:</p>
<pre>   $ mse -d --file example1.mse
</pre>
<p></p>
<pre>   Reformat the script:
       for (i = 0; i &lt; 10; i = i + 1) {
         x=i*i;
         echo The square value of %i is %x;
         if (x == 30) {
           abort;
         }
         else if (x &gt; 45) {
           done;
         }
       }
</pre>
<p></p>
<p>Notes:</p>
<p>a. All comments are lost. A side effect of the dumping is that the lines will be checked for missing semicolons and appropriate warnings will be issued.</p>
<p>b. Variables in flow control or mse-specific statements (initial, conditional, update, assignment) do not need to have a leading macro symbol. But variables in BALI commands (such as the echo command above) need to have a leading macro to be expanded.</p>
<p>c. The reformatting is advisory. The reformatted output must be manually checked for accuracy.</p>
<p>4.  To dump out the script in one line:</p>
<pre>   $ mse -o --file example1.mse
</pre>
<p></p>
<pre>   Reformat the script in one line and save to environment variable:
   MSE_SCRIPT=for (i=0;i&lt;10;i=i+1) { x=i*i; echo The square value of %i is %x; if (x&gt;30) {abort;} else if (x&gt;45) {done;} }
</pre>
<p></p>
<p>5. To execute the script saved in the MSE_SCRIPT environment variable:</p>
<pre>   $ env --name MSE_SCRIPT
   MSE_SCRIPT=for (i=0;i&lt;10;i=i+1) { x=i*i; echo The square value of %i is %x; if (x&gt;30) {abort;} else if (x&gt;45) {done;} }
</pre>
<p></p>
<pre>   $ mse "$MSE_SCRIPT"   # variable substitution in the context of the BALI shell
   $ mse %%MSE_SCRIPT    # variable expanded during preprocessing phase
</pre>
<p></p>
<p>6. Use verbatim escape sequences with nested mse commands (see section C4.2):</p>
<pre>   $ mse 'echo x; mse @waecho y; echo @wxz@wx@wa'
</pre>
<p></p>
<pre>   The first mse command sees two statements after phase 2:
      echo x;
      mse 'echo y; echo @wxz@wx'
</pre>
<p></p>
<pre>   The last statement is an mse command. When run in the BALI console,
   it will see two statements after its pass #2:
      echo y;
      echo 'z'
</pre>
<p></p>
<pre>   Each statement is executed by invoking the BALI command.
   Thus, the output of the original command is as follows:
   x
   y
   z
</pre>
<p></p>
<p>In general, verbatim escape sequences can be used to enclose arguments of nested commands. Table 4 of the quoted-text man page defines 15 verbatim escape sequences, but the actual number is much greater. This is because the letter 'x' in the last three rows of the table actually represents any upper or lower alphanumeric character.</p>
<p>7. Use command substitution feature:</p>
<pre>   $ mse 'echo Total directory entries: %(ls | wc -l)'
   Total directory entries: 15
</pre>
<p></p>
<p>8. Use arithmetic substitution feature:</p>
<pre>   $ mse-set x 4
   $ mse 'echo Total count: %((3+x))'
   Total count: 7
</pre>
<p></p>
<p>9. Commands using global MSE</p>
<pre>   $ mse 'for (i = 0; i &lt; 10; i = i+1) { echo create file%i; touch file%i; }'
   $ mse --shared-env 'for (i = 0; i &lt; 10; i = i+1) { echo create file%i; touch file%i; }'
   $ mse --global-env 'for (i = 0; i &lt; 10; i = i+1) { echo create file%i; touch file%i; }'
   $ mse-env --name i
   i=10
</pre>
<p></p>
<p>The first three mse commands are functionally equivalent because they use the same global minishell environment. Note variable i is persistent after the commands exit and can be dumped by the mse-env command.</p>
<p>10. Command using local MSE</p>
<pre>   $ mse --local-env 'for (j = 20; j &lt; 25; j = j+1) { echo create file%j; }'
   $ mse-env --name j   # This command dumps global MSE
   Undefined variable name: j
</pre>
<p></p>
<p>Variable j is gone when the mse command terminates because it is stored in a local MSE.</p>
<p>11. Command using the parent MSE</p>
<pre>   $ mse --local-env 'for (k = 0; k &lt; 10; k = k+1) { mse "m = k*k; echo m = %m;" }'
   $ mse --local-env 'for (k = 0; k &lt; 10; k = k+1) { mse --shared-env "m = k*k; echo m = %m;" }' # same as above
   $ mse-env --name k
   Undefined variable name: k
   $ mse-env --name m
   Undefined variable name: m
</pre>
<p></p>
<p>The first two mse commands are functionally equivalent. The mse commands in the body of the for-loop use the parent MSE. Note both variables m and k are gone when the leftmost mse command terminates.</p>
<p>12. Command using local MSE</p>
<pre>   $ mse --local-env 'for (a = 0; a &lt; 10; a = a+1) { mse --local-env "b = a*a; echo b = %b;" }'
</pre>
<p></p>
<p>Note that the two mse commands use their own local MSE and hence their variables are encapsulated. Thus, the second mse command fails because variable "a" is not defined.</p>
<p>13. Command using inherited environment</p>
<pre>   $ mse 'b=2; echo b=%b; mse --inherited-env "y=b+5; b=b+1; echo b1=%b, y=%y; "; echo b2=%b;'
   b=2
   b1=3
   y=7
   b2=2
</pre>
<p></p>
<p>Note that the second mse command uses a copy of the MSE of the first command. Therefore, the modification to variable 'b' in the second mse command does not affect the variable 'b' in the MSE of the first command.</p>
<p>14. Define function on the fly and call it</p>
<pre>    $ mse 'function say { echo Please say %1; } call say hi; '
    Please say hi
</pre>
<p></p>
<p>15. Load functions from files and call</p>
<pre>    $ sscat func.mse  # Dump file func.mse from flash
    function say {
      echo Please say %1;
    }
    function bye {
      echo Bye %.args
    }
</pre>
<p></p>
<p>There are many ways to call a function:</p>
<pre>    $ mse -L func.mse --call say hi
    $ mse -L func.mse call say hi   # note 'call' begins the mse script
    $ mse --call func::say hi       # "func::" causes file func.mse to be searched
    $ mse call func::say hi         # note 'call' begins the mse script
    $ mse --call func::say hi       # note no mse script is specified on command line.
    Please say hi
</pre>
<p></p>
<p>Note the first two commands load all functions in the file although only one function is used. The next three commands load only the specified function.</p>
<p>16. How to change variable names dynamically?</p>
<p>A use case is to use variable x%i in a loop, i.e., the variable name changes dynamically.  The solution is to use curly brackets to enclose the variable name to change the order of variable substitution.</p>
<p>Example:</p>
<pre>    $ sscat array.mse
    x1:=Fred;
    x2:=Ken;
    x3:=Hoc;
    for (i=1; i&lt;4; i=i+1) {
      y%i=i*i;
      # force index %i to be evaluated first
      echo Hello %{x%i}, you get y%i=%{y%i};
    }
</pre>
<p></p>
<pre>    $ mse -f array.mse
    Hello Fred, you get y1=1
    Hello Ken, you get y2=4
    Hello Hoc, you get y3=9
</pre>
<p></p>
<p>17. Run mse as a filter</p>
<pre>    a) Access the output of the preceding command:
</pre>
<p></p>
<pre>       $ echo Hello | mse 'len=strlen("%.__"); echo len=%len;'
       len=5
</pre>
<p></p>
<pre>    b) Use filter with positional parameters
</pre>
<p></p>
<pre>       $ echo -e echo Hello %1. I need to talk to %.__\E | sstee test2.mse
       echo Hello %1. I need to talk to %.__;
</pre>
<p></p>
<pre>       $ sscat test2.mse
       echo Hello %1. I need to talk to %.__;
</pre>
<p></p>
<pre>       $ echo Tom | mse -f test2.mse Dave
       Hello Dave. I need to talk to Tom
</pre>
<p></p>
<pre>    c) Mimic the Linux awk command
       This is achieved by specifying the init and final scripts
</pre>
<p></p>
<pre>       $ sscat data.txt # has 3 lines
       10
       20
       30
</pre>
<p></p>
<pre>       $ sscat data.txt | mse -S 'sum=0; echo Compute total' -X 'echo Total %.____ lines: %sum' '{sum = sum + %.__;}'
       Compute total
       Total 3 lines: 60
</pre>
<p></p>
<pre>       $ sscat data.txt | mse -S 'sum=0;' -X 'echo Weighted total: %sum' '{sum = sum + %.____*%.__;}'
       Weighted total: 140
</pre>
<p></p>
<p>18. Change abort-on-error flag on the fly, noting that the change affects all child mse commands:</p>
<pre>    $ mse 'call abort-on-error; call abort-on-error on; call abort-on-error; mse call abort-on-error'
    0
    1
    1
</pre>
<p></p>
<p>19. Handle default arguments to functions or scripts</p>
<p>There are many ways to handle default arguments to functions or scripts. One way is to use the built-in function isempty() or isemptytoken().</p>
<p>The function isempty(s) tests if s is missing, or an undefined variable, or a variable whose value is an empty string. Before testing, isempty() expands all macros in the argument.</p>
<p>The function isemptytoken(s) tests if the token s is missing or an empty string. Before testing, isemptytoken() expands all macros in the argument.</p>
<p>For more information, see example 16 in the 'calculate' man page.</p>
<pre>    $ sscat test.mse
    function hello {
      x := %1;
      if (isempty(x))    # or: if (isempty("%1"))
      {
        x := everyone;   # default is to say Hello everyone
      }
      echo Hello %x;
    }
</pre>
<p></p>
<pre>    # x is a variable that has no value:
    $ mse -f test::hello
    Hello everyone
</pre>
<p></p>
<pre>    # x is a variable that has a non-empty string value:
    $ mse -f test::hello Carl
    Hello Carl
</pre>
<p></p>
<p>Let's consider a variant:</p>
<pre>    $ sscat test1.mse
    function hello1 {
      x := %1;
      if (isempty(%1)) {
        x := everyone;
      }
      echo Hello %x;
    }
</pre>
<p></p>
<pre>    $ mse -f test1::hello1 Carl
    Hello everyone
</pre>
<p></p>
<p>This comes about because isempty(%1) becomes isempty(Carl) when executed. Thus, Carl becomes a variable, which is considered empty because it has not been defined yet.</p>
<p>If isempty() is replaced with isemptytoken() in test.mse and test1.mse, we will get:</p>
<pre>    $ mse -f test::hello
    Hello everyone
</pre>
<p></p>
<pre>    $ mse -f test1::hello1 Carl
    Hello Carl
</pre>
<p></p>
<p>20. Parsing rule</p>
<p>Example 1 of the EXAMPLES section explains how the mse command parses and builds the complete script from individual tokens on the command line. The complete script is a single string. To see how this works, compare the following two examples:</p>
<pre>    Example (a):
</pre>
<p></p>
<pre>        $ echo abc | mse echo "xy%{.__}}zz"
        Mismatched delimiter: 1 extra }
        echo xy%{.__}}zz
                 ^
        Failed syntax when processing input line #1
</pre>
<p></p>
<pre>    Example (b):
</pre>
<p></p>
<pre>        $ echo abc | mse 'echo "xy%{.__}}zz"'
        xyabc}qw
</pre>
<p></p>
<p>Let's identify the mse scripts:</p>
<pre>    - mse script in example (a): 'echo xy%{.__}}zz'
      This causes mse to run the script as a BALI command:
</pre>
<p></p>
<pre>          $ echo xy%{.__}}zz
</pre>
<p></p>
<pre>      The curly brackets are special to the BALI shell, which finds the syntax invalid.
</pre>
<p></p>
<pre>    - mse script in example (b): 'echo "xy%{.__}}zz"'
      This causes mse to run the script as a BALI command:
</pre>
<p></p>
<pre>          $ echo "xy%{.__}}zz"
</pre>
<p></p>
<pre>      The curly brackets are normal text, hence, the command succeeds.
</pre>
<p></p>
<p>21. Display execution traces</p>
<pre>    $ sscat for.scr
    sum=0;
    for (i=5; i&lt;7; i=i+1) {
     if (i == 5) {
       echo Find sum of integers;
     }
     sum = sum+i;
     echo Integer i = %i;
     echo Sum = %sum;
    }
</pre>
<p></p>
<p>Note the higher the trace level, the more verbose the trace.</p>
<pre>    $ mse --trace-level 3 -f for.scr
         #### [Execute] sum=0
</pre>
<p></p>
<pre>         #### [Process loop] for (i=5; i&lt;7; i=i+1)
</pre>
<p></p>
<pre>         #### [for-loop initial] i=5 ==&gt; 5               &lt;&lt;&lt;&lt; require level &gt;=3
         #### [for-loop conditional] i&lt;7 ==&gt; true        &lt;&lt;&lt;&lt; require level &gt;=3
         #### [for-loop] iteration 1
           #### [Execute] if (i == 5) ==&gt; true           &lt;&lt;&lt;&lt; require level &gt;=2
              #### [Execute] echo Find sum of integers
    Find sum of integers
           #### [Execute] sum = sum+i
           #### [Execute] echo Integer i = %i
    Integer i = 5
           #### [Execute] echo Sum = %sum
    Sum = 5
</pre>
<p></p>
<pre>         #### [for-loop update] i=i+1 ==&gt; 6             &lt;&lt;&lt;&lt; require level &gt;=3
         #### [for-loop conditional] i&lt;7 ==&gt; true       &lt;&lt;&lt;&lt; require level &gt;=3
         #### [for-loop] iteration 2
           #### [Execute] if (i == 5) ==&gt; false         &lt;&lt;&lt;&lt; require level &gt;=2
           #### [Execute] sum = sum+i
           #### [Execute] echo Integer i = %i
    Integer i = 6
           #### [Execute] echo Sum = %sum
    Sum = 11
</pre>
<p></p>
<pre>         #### [for-loop update] i=i+1 ==&gt; 7             &lt;&lt;&lt;&lt; require level &gt;=3
         #### [for-loop conditional] i&lt;7 ==&gt; false      &lt;&lt;&lt;&lt; require level &gt;=3
</pre>
<p></p>
<pre>    $ mse --trace-level 2 -f for.scr
         #### [Execute] sum=0
</pre>
<p></p>
<pre>         #### [Process loop] for (i=5; i&lt;7; i=i+1)
</pre>
<p></p>
<pre>         #### [for-loop] iteration 1
           #### [Execute] if (i == 5) ==&gt; true          &lt;&lt;&lt;&lt; require level &gt;=2
              #### [Execute] echo Find sum of integers
    Find sum of integers
           #### [Execute] sum = sum+i
           #### [Execute] echo Integer i = %i
    Integer i = 5
           #### [Execute] echo Sum = %sum
    Sum = 5
         #### [for-loop] iteration 2
           #### [Execute] if (i == 5) ==&gt; false
           #### [Execute] sum = sum+i
           #### [Execute] echo Integer i = %i
    Integer i = 6
           #### [Execute] echo Sum = %sum
    Sum = 11
</pre>
<p></p>
<pre>    $ mse --trace-level 1 -f for.scr
         #### [Execute] sum=0
</pre>
<p></p>
<pre>         #### [Process loop] for (i=5; i&lt;7; i=i+1)
</pre>
<p></p>
<pre>         #### [for-loop] iteration 1
              #### [Execute] echo Find sum of integers
    Find sum of integers
           #### [Execute] sum = sum+i
           #### [Execute] echo Integer i = %i
    Integer i = 5
           #### [Execute] echo Sum = %sum
    Sum = 5
         #### [for-loop] iteration 2
           #### [Execute] sum = sum+i
           #### [Execute] echo Integer i = %i
    Integer i = 6
           #### [Execute] echo Sum = %sum
    Sum = 11
</pre>
<p></p>
<p>22. Differences between mse and ssrun (or repeat)</p>
<p>Their syntax can be summarized as follows:</p>
<pre>       ssrun -c &lt;command line&gt;
       repeat [options] &lt;command line&gt;
       mse [options] &lt;series of command lines&gt;
</pre>
<p></p>
<p>The differences are as follows:</p>
<p>1.  'ssrun -c' and repeat support only one command line whereas mse can execute multiple command lines, one after another.</p>
<p>2.  mse processes one command line at a time. It does not resolve escapes and sequences for all command lines in one pass. Rather, it resolves for one command at a time, just before the command is executed.</p>
<p>3. 'ssrun -c' and repeat simply execute the command line as is; they do not try to resolve any macros and escape sequences.</p>
<p>Example:</p>
<pre>    $ sscat testssrun.mse
    mse-env | mse-unset;
    mse-set -v list monday;
    ssrun -c "mse -m ^ 'list := ^list,tuesday; echo list1=^list'; echo list2=%list; mse-set -v list %list,wednesday"
    echo list4 = %list
</pre>
<p></p>
<pre>    $ mse -f testssrun.mse
    list=monday
    list1=monday,tuesday
    list2=monday
    list=monday,wednesday
    list4 = monday,wednesday
</pre>
<p></p>
<p>Note that 'list2' is not 'monday,tuesday' and 'list4' is not 'monday,tuesday,wednesday'. To understand this, note there are two instances of 'mse' running:</p>
<pre>    - first mse runs:  mse -f 'testssrun.mse'
    - second mse runs: mse -m ^ 'list := ^list,tuesday; echo list1=^list'
</pre>
<p></p>
<p>When the first mse processes 'ssrun', it will resolve all arguments of ssrun in one pass as follows:</p>
<pre>    ssrun -c "mse -m ^ 'list := ^list,tuesday; echo list1=^list'; echo list2=monday; mse-set -v list monday,wednesday"
</pre>
<p></p>
<p>Then ssrun executes this command line as if users typed in three commands:</p>
<pre>    mse -m ^ 'list := ^list,tuesday; echo list1=^list'
    echo list2=monday
    mse-set -v list monday,wednesday
</pre>
<p></p>
<p>Thus, regardless of what the second mse instance tries to change the 'list' variable to, the final 'mse-set' command resets it to 'monday,wednesday'.</p>
<p>In general, using ssrun and repeat commands in an mse script can give results that are hard to debug. The key to understanding the results is that variables in their arguments are expanded at once in one pass. Their uses in an mse script are discouraged because mse can provide all of their functionalities.</p>
<p>23. Use string quoting functions in command line arguments</p>
<pre>  $ sscat test.scr
  echo Create files
  touch str(Hoc's report)        # str() is a quoting function
  ls -l str(Hoc's report)
  touch "str(Hoc's report)"      # str() is normal text, not a function, because of the enclosing quotes.
  ls -l "str(Hoc's report)"
</pre>
<p></p>
<pre>  $ mse -f test.scr
  Create files
  -rwxrwxrwx    -  1        0        0         0 2016-08-31 02:16:36-07:00 Hoc's report
  -rwxrwxrwx    -  1        0        0         0 2016-08-31 02:16:36-07:00 str(Hoc's report)
</pre>
<p></p>
<p>as a string-quoting function. Thus, the command had two arguments: "str(Hoc's" and "report)". The first argument was not enclosed in double quotes, hence, the failure.</p>
<h1>Applies To</h1>
<p>Cluster node</p>
<h1>See Also</h1>
<p><a href="../../Dev/backquote.html">backquote</a> <a href="../../Filter/Dev/calculate.html">calculate</a> <a href="../../User/echo.html">echo</a> <a href="../../Dev/env.html">env</a> <a href="../../Dev/env-config.html">env-config</a> <a href="../../Filter/Dev/env-set.html">env-set</a> <a href="../../Filter/Dev/env-unset.html">env-unset</a> <a href="../../Topic/macro-support.html">macro-support</a> <a href="../../Dev/mse.html">mse</a> <a href="../../Dev/mse-abort.html">mse-abort</a> <a href="../../Dev/mse-config.html">mse-config</a> <a href="../../Topic/mse-env.html">mse-env</a> <a href="../../Topic/mse-functions.html">mse-functions</a> <a href="../../Filter/Dev/mse-run.html">mse-run</a> <a href="../../Filter/Dev/mse-set.html">mse-set</a> <a href="../../Topic/mse-unit-testing.html">mse-unit-testing</a> <a href="../../Filter/Dev/mse-unset.html">mse-unset</a> <a href="../../Topic/quoted-text.html">quoted-text</a> <a href="../../Filter/User/sort.html">sort</a> <a href="../../Supervisor/sscat.html">sscat</a> <a href="../../Supervisor/ssdiff.html">ssdiff</a> <a href="../../Supervisor/ssls.html">ssls</a> <a href="../../Supervisor/ssput.html">ssput</a> <a href="../../User/ssrun.html">ssrun</a> <a href="../../Filter/User/sstee.html">sstee</a> <a href="../../Filter/Dev/sswrdata.html">sswrdata</a> <a href="../../Filter/Dev/strjoin.html">strjoin</a> <a href="../../Filter/Dev/strquery.html">strquery</a> <a href="../../Filter/Dev/strsplit.html">strsplit</a></p>
<h1>Privilege Level</h1>
<p>Dev</p>
<blockquote></blockquote>
<!--End footer-->
</body>
</html>
