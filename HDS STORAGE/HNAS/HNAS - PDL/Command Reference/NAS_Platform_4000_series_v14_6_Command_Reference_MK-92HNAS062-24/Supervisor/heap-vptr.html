<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>heap-vptr</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
  <!--
  @page { size: 8.27in 11.69in }
  H1  { font-family: "Verdana", sans-serif }
  H2  { font-family: "Verdana", sans-serif }
  H3  { font-family: "Verdana", sans-serif }
  H4  { font-family: "Verdana", sans-serif }
  P   { font-family: "Verdana", sans-serif; font-size: 11pt; margin-left: 40px; }
  PRE { font-family: "Courier", monospace;  font-size: 12pt; margin-left: 40px; }
  DT  { font-family: "Verdana", sans-serif; font-size: 11pt; margin-left: 40px; }
  LI  { font-family: "Verdana", sans-serif; font-size: 11pt; margin-left: 40px; }
  -->
  </style>

</head>
<body style="background-color: white">
<!--Start header -->
<!-- html created: 2023-03-05 07:29:14 +0000 oemId: 1 -->
<h1>heap-vptr</h1>
<p>Analyze heap usage</p>
<h1>Syntax</h1>
<pre>heap-vptr [--all | --density] [--by-total-size] [--slot-begin &lt;n&gt;] [--to-the-last-slot | --slot-end &lt;n&gt;] [--size &lt;size&gt;] [--sequence-gt &lt;seq&gt;] [--sequence-le &lt;seq&gt;] [--fiber &lt;id&gt;] [--address-ge &lt;address&gt;] [--address-lt &lt;address&gt;] [--previous-block-free] [--previous-free-block-size-ge &lt;size&gt;] [--marker &lt;marker&gt; | [--marker-ne &lt;marker&gt;] | [--marker-ge &lt;marker&gt;] [--marker-lt &lt;marker&gt;]]
</pre>

<h1>Description</h1>
<p>The heap-vptr command scans the whole heap on the currently selected board, inspecting the first pointer in each allocated heap block. It counts how many times each virtual function table pointer is encountered and emits a high-score table at the end of the scan.  This can help you determine if there is an unusual or continually increasing number of any particular object.  The command is quick and safe and it is often easy for Engineering to see from the results whether there is a problem.</p>
<p>Allocations which overflowed from pools to the heap will be scanned. The contents of pools themselves are not scanned. This is no loss for most pools, which contain homogeneous objects, as their fill levels can be inspected with poolstats. Size-based pools can be scanned with pool-vptr.</p>
<p>The --all option gives a complete list of all the virtual function table pointers which were encountered.  It is only usually useful, in conjunction with grep, when testing for a particular object of interest.</p>
<p>The --density option calls heap-density --vptr-is with each of the top-ten most frequent vptrs. The output may suggest that the allocation type causing the worst heap fragmentation isn't the most frequent allocation type.</p>
<p>The --by-total-size switch sorts by and displays the total size of all the eligible blocks with the same vptr. The default behavior is to sort by and display their frequency. On rare occasions, an infrequent but large allocation has played a significant role.</p>
<p>The --slot-begin and --slot-end switches delineate a half-open range of vptr slots within each allocation to be sampled for vptrs. The defaults are zero and one respectively, meaning that only the primary vptr - the first slot - will be sampled. Use --all-slots to sample as much of the object as the code deems expedient.</p>
<p>The --size switch allows the search to be restricted to heap blocks of exactly the specified size. This is the size passed to malloc plus the overhead incurred for:</p>
<ul>
<li>the heap block header, which is sizeof(void*) in the release build</li>
<li>alignment, which was 2 * sizeof(void*) historically but we're considering using 64 B, the cache line size</li>
<li>unwillingness to split blocks of less than 6 * sizeof(void*) or the alignment, whichever is smaller</li>
</ul>
<p>The --sequence-gt, --sequence-le and --fiber switches rely on instrumentation with an overhead such that it's not normally compiled into the release build. The sequence switches really do specify a half-open range the unusual way round, unlike the address switches explained below. The reason being that the sequence number reported by heap-seq is that of the last allocation.</p>
<p>The --address-ge and --address-lt switches allow a half-open range of addresses to be specified. "ge" is greater or equal. "lt" is less than. Blocks outside the range are ignored. This is useful in conjunction with heap-density to concentrate investigative efforts away from bulk allocations, such as those which occur at boot-time and when an EVS starts or a file system is mounted, where such allocations can be shown not to be causing fragmentation.</p>
<p>The --previous-block-free restricts the scan to those allocations preceded by a free block. It is theorized that such allocations play a greater role in heap fragmentation than allocations adjacent to other allocated blocks.</p>
<p>The --previous-free-block-size-ge switch restricts the search to allocations preceded by a free block of a size at least that given by the argument. It is theorized that usage patterns may result in some allocation types occurring disproportionately frequently after large free blocks. Such allocations would almost certainly play a greater role in heap fragmentation than allocations preceded by smaller free blocks. "64K" is thought to be a size of particular interest. The size may be specified with a multiplier, such as "K", "KB" or "KiB", denoting 1024 bytes. There must be no space between the count and the multiplier.</p>
<p>The heap marker options allow the selection of blocks of various ages for display. See 'heap_markers' for an explanation.  In particular, the command</p>

<p>heap-vptr --marker-lt 6</p>

<p>limits the output data to the blocks allocated since the point ten minutes after boot. This is an exact version of what the 'heap-density' "elbow-finding" code was attempting to produce.</p>
<p>There are a huge number of different states it's possible for a well-performing heap to be in at the instance the results are taken.  There are a similar variety of states for a badly performing heap.  This makes it very difficult to give advice on how to interpret the results. Familiarity with normal-looking results, both generally and for a particular system, is useful.  Sometimes a particular problem has an easily recognizable signature.  Two classes of problem manifest themselves as more than 10 000 "allocated blocks starting without a vptr".  If you see that, then Engineering would like access to the system.</p>
<h1>Examples</h1>
<pre>server$ fsm heap-vptr
...
434 HeapVPtrAllocationHeader&lt;std::_Hashtable_node&lt;std::pair&lt;InplaceString&lt;char, InplaceCharTraits&lt;char&gt; &gt; const, ConsoleCommand*&gt; &gt;, std::__malloc_alloc_template&lt;0&gt; &gt; (vptr 0x10510A98)
553 Trace (vptr 0x1084311C)
768 HeapVPtrAllocationHeader&lt;char, std::__malloc_alloc_template&lt;0&gt; &gt; (vptr 0x104F6B38)
1734 HeapVPtrAllocationHeader&lt;std::_Rb_tree_node&lt;void const*&gt;, std::__malloc_alloc_template&lt;0&gt; &gt; (vptr 0x1054FC08)
2049 HeapVPtrAllocationHeader&lt;std::_List_node&lt;net::ipreassembly::Reassembler&lt;net::ipv6::Address&gt;*&gt;, std::__malloc_alloc_template&lt;0&gt; &gt; (vptr 0x10533F98)
2049 HeapVPtrAllocationHeader&lt;std::_List_node&lt;net::ipreassembly::Reassembler&lt;net::ipv4::IPAddress&lt;unsigned&gt; &gt;*&gt;, std::__malloc_alloc_template&lt;0&gt; &gt; (vptr 0x10533FF8)
2049 HeapVPtrAllocationHeader&lt;std::_List_node&lt;net::ipreassembly::ReassemblyStatus*&gt;, std::__malloc_alloc_template&lt;0&gt; &gt; (vptr 0x10534658)
3468 HeapVPtrAllocationHeader&lt;std::_Rb_tree_node&lt;std::pair&lt;void const* const, unsigned&gt; &gt;, std::__malloc_alloc_template&lt;0&gt; &gt; (vptr 0x1052F480)
4096 HeapVPtrAllocationHeader&lt;std::_Rb_tree_node&lt;std::pair&lt;unsigned const, MsgbPtr&gt; &gt;, std::__malloc_alloc_template&lt;0&gt; &gt; (vptr 0x10533FA8)
8192 HeapVPtrAllocationHeader&lt;std::_List_node&lt;RCPtr&lt;net::arp::CacheEntryObserver, RCPtrTraits&lt;net::arp::CacheEntryObserver, net::arp::CacheEntryObserver*, net::arp::CacheEntryObserver&amp;&gt; &gt; &gt;, std::__malloc_alloc_template&lt;0&gt; &gt; (vptr 0x10504C30)
There were 27598 allocated blocks starting with a vptr of which only 25392 were displayed.
There were 358 allocated blocks starting without a vptr, making for a total of 27956 allocated blocks.
server$
</pre>
<p></p>
<h1>Applies To</h1>
<p>Cluster node</p>
<h1>See Also</h1>
<p><a href="../Supervisor/heap-density.html">heap-density</a> <a href="../Supervisor/heap-info.html">heap-info</a> <a href="../Supervisor/heap-size.html">heap-size</a> <a href="../Topic/heap_markers.html">heap_markers</a> <a href="../Supervisor/pool-vptr.html">pool-vptr</a> <a href="../Supervisor/poolstats.html">poolstats</a></p>
<h1>Privilege Level</h1>
<p>Supervisor</p>
<blockquote></blockquote>
<!--End footer-->
</body>
</html>
