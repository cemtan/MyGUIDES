<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>env-set</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
  <!--
  @page { size: 8.27in 11.69in }
  H1  { font-family: "Verdana", sans-serif }
  H2  { font-family: "Verdana", sans-serif }
  H3  { font-family: "Verdana", sans-serif }
  H4  { font-family: "Verdana", sans-serif }
  P   { font-family: "Verdana", sans-serif; font-size: 11pt; margin-left: 40px; }
  PRE { font-family: "Courier", monospace;  font-size: 12pt; margin-left: 40px; }
  DT  { font-family: "Verdana", sans-serif; font-size: 11pt; margin-left: 40px; }
  LI  { font-family: "Verdana", sans-serif; font-size: 11pt; margin-left: 40px; }
  -->
  </style>

</head>
<body style="background-color: white">
<!--Start header -->
<!-- html created: 2023-03-07 10:20:39 +0000 oemId: 1 -->
<h1>env-set</h1>
<p>Set an environment variable</p>
<h1>Syntax</h1>
<pre>... | env-set [options] [--eof &lt;eof-marker&gt;] &lt;name&gt; &lt;value&gt;
	     where
	     options ::= [--verbose|--terse] [--init-only] [--update-only] [--escape-char &lt;char&gt;] [--macro-symbol &lt;char&gt;] [--newline-replacement &lt;string&gt;]
</pre>

<h1>Description</h1>
<p>This command assigns a value to a BALI console environment variable. It can also be run as a filter.</p>
<p>A BALI console environment variable name is a string of characters. The first character in the name must be an alphabetic letter or an underscore. Subsequent characters can be alphanumeric or underscores.</p>
<p>Options:</p>
<dl>
<dt><strong>--verbose, -v</strong></dt>
<dd><p>Display the name and the value of the variable in the form: &lt;name&gt;=&lt;value&gt;.</p></dd>
<dt><strong>--terse, -t</strong></dt>
<dd><p>Display only the value of the variable.</p></dd>
<dd><p>Options --verbose and --terse are mutually exclusive. If none of them is specified, the output will be suppressed.</p></dd>
<dt><strong>--init-only, -i</strong></dt>
<dd><p>Set the variable if and only if it is undefined (not set yet). If the variable already exists, the command does not change its value and does not fail, either. This is because the user has requested that no action be taken if the variable already exists.</p></dd>
<dt><strong>--update-only, -u</strong></dt>
<dd><p>Set the variable if and only if it is already defined (already set). If the variable does not exist, the command does not create a new variable and does not fail, either. This is because the user has requested that no action be taken if the variable does not exist.</p></dd>
<dt><strong>--escape-char, -e &lt;character&gt;</strong></dt>
<dd><p>Specify the escape character. By default, the command does not support escape sequences in the &lt;value&gt;.</p></dd>
<dd><p>If the escape character is specified, all occurrences of the escape character in the &lt;value&gt; will be decoded based on the escape sequences defined in the quoted-text man page.</p></dd>
<dt><strong>--macro-symbol, -m &lt;character&gt;</strong></dt>
<dd><p>Specify the macro symbol. By default, the command does not support macros in the &lt;value&gt;.</p></dd>
<dd><p>If the macro symbol is specified, all occurrences of the macro symbol in the &lt;value&gt; will be interpreted as described in the macro-support man page. Specifically, the macro symbol can trigger variable substitution, command output substitution, or arithmetic expansion.</p></dd>
<dd><p>If both the escape character and the macro symbol are specified, their appearances in the &lt;value&gt; are usually resolved by scanning &lt;value&gt; from left to right in one pass.</p></dd>
<dt><strong>--newline-replacement, -n &lt;string&gt;</strong></dt>
<dd><p>Replace all the newlines in &lt;value&gt; with &lt;string&gt;. Note that this step is performed after resolving all escapes and macros.</p></dd>
<dt><strong>--eof &lt;end-of-file-marker&gt;</strong></dt>
<dd><p>This option must appear after all other options and before the variable name. It specifies that the value of the variable begins at the line immediately following the command line and can span over multiple lines. This option is usually used when the value of a variable contains newline characters or characters that are special to the shell.</p></dd>
<dd><p>The command will read all subsequent lines in the standard input, line by line, until it sees the specified &lt;end-of-file-marker&gt; string on a separate line by itself. The &lt;end-of-file-marker&gt; line and the newline character before it will be discarded because they are not part of the value.</p></dd>
<dd><p>Because the subsequent lines are read by the command, not the shell, all characters therein are not interpreted by the shell. Thus, there is no need to escape dollar signs, single and double quotes, etc.</p></dd>
<dd><p>Note that if env-set is used in an mse script, this option has different behavior depending on how the option name is specified (see Section C8.3.6 of the mse man page for explanation and examples).</p></dd>
<dd><p>If the full spelling "--eof" is specified, the option will be processed in the context of the mse command, and hence, all the data must be specified below the env-set command line.</p></dd>
<dd><p>If the partial spelling "--eo" is specified, the option will be processed in the context of the env-set command. Thus, the user has to enter the data interactively everytime the mse script is run.</p></dd>
<dd><p>Note that the former name of this option is --value-follows-until|-V &lt;end-marker&gt;. It is still supported but will be phased out.</p></dd>
<dt><strong>&lt;variable name&gt;</strong></dt>
<dd><p>Specify the name of the environment variable.</p></dd>
<dt><strong>&lt;value&gt;</strong></dt>
<dd><p>Specify the value of the environment variable. This argument must be specified after the &lt;name&gt; argument.</p></dd>
<dd><p>If --eof is specified, then &lt;value&gt; can span over multiple lines as described above.</p></dd>
</dl>
<h2>Run as a filter</h2>
<p>Syntax:</p>
<pre>      &lt;command...&gt; | env-set [options] &lt;name&gt;
</pre>
<p></p>
<p>where options are the same as those described in the command, except --escape-char, --macro-symbol, and --eof.</p>
<p>When env-set is run as a filter, the value of the environment variable is the entire standard output of the preceding command in the chain with the following exception. If the entire output ends with a sequence of one or more consecutive newline characters, the sequence will be removed from the output. The remaining newlines in the output are preserved but can be replaced with another string if the --newline-replacement option is specified.</p>
<p>Notes:</p>
<p>1) The --terse option can be specified to pass the standard input of env-set as is to the next filter in the chain.</p>
<p>2) Earlier versions of the filter support option '--use-line-separator &lt;string&gt;'.  This option is still available but is now superseded by --newline-replacement &lt;string&gt;.</p>
<p>3) There are other ways to assign a value to a variable in the BALI environment. See the man page for 'backquote' and 'calculate' commands for more information.</p>
<h1>Examples</h1>
<p>1. Define a new environment variable name COUNT and set its value to 4:</p>
<pre>   $ env-set -v COUNT 4
   COUNT=4
</pre>
<p></p>
<p>Assignments can be done with the 'backquote' or 'calculate' commands. For instance,</p>
<pre>   $ backquote VAL echo 5
   $ env --name VAL
   VAL=5
</pre>
<p></p>
<pre>   $ calculate VALUE=10-4
   $ env --name VALUE
   VALUE=6
</pre>
<p></p>
<pre>   $ calculate 'MSG = "Hello world"'
   $ env --name MSG
   Hello world
</pre>
<p></p>
<p>2. Use as a filter</p>
<pre>   $ echo "Values: 3 5 0x12 6 0x26 10" | strtoken %2 | env-set -v COUNT
   COUNT=3
</pre>
<p></p>
<p>Let the standard input of env-set pass through:</p>
<pre>   # Find out the standard input of env-set:
   $ echo "Values: 3 5 0x12 6 0x26 10" | strtoken %2
   3
</pre>
<p></p>
<pre>   # Pass through env-set
   $ echo "Values: 3 5 0x12 6 0x26 10" | strtoken %2 | env-set -t COUNT | calculate __+5
   8
</pre>
<p></p>
<p>3. Change COUNT to 6</p>
<pre>   $ env-set -v COUNT 6
   COUNT=6
</pre>
<p></p>
<p>4. Initialize COUNT if and only if it has not been defined:</p>
<pre>   $ env-set -i -v COUNT 10
   COUNT=6
</pre>
<p></p>
<p>5. Update XCOUNT if and only if XCOUNT exists:</p>
<pre>   $ env-set -u XCOUNT 3
   $ env-set -u -v XCOUNT 3  # -v to show output
   XCOUNT=
   $ env -n XCOUNT
   Undefined variable name: XCOUNT
</pre>
<p></p>
<p>6. Define value that contains escape sequences</p>
<pre>   $ env-set -v -e \ message "John's book entitled \QGood Programming Practice\Q"
   message=John's book entitled "Good Programming Practice"
</pre>
<p></p>
<p>7. Value spanning over multiple lines</p>
<p>Suppose we want to store 3 lines into a variable called 'cmds':</p>
<pre>       touch file
       wrfile file -n 1MB
       file-clone-create file clone
</pre>
<p></p>
<p>If we run env-set interactively, we can type the command as follows:</p>
<pre>       $ env-set --eof END  cmds
       touch file
       wrfile file -n 1MB
       file-clone-create file clone
       END
</pre>
<p></p>
<p>Note that the BALI shell processes the command line starting with 'env-set' but does not know the subsequent lines. All lines below the command line are read and processed by the env-set command alone.</p>
<p>8. Avoid BALI shell interpretation of special characters in the value</p>
<p>If we do not want the BALI shell to interpret the value, we need to use --eof option and enter the value below the command line, i.e.,</p>
<pre>       $ env-set --eof END  cmds
       touch file
       wrfile file -n 1MB
       file-clone-create file clone
       END
</pre>
<p></p>
<p>If the env-set command is used in a cript, the method above does not work. We have to use the escape mechanism instead:</p>
<pre>       $ env-set -e \ cmds 'touch file\nwrfile file -n 1MB\nfile-clone-create file clone'
</pre>
<p></p>
<p>Verify:</p>
<pre>       $ env -t -n cmds
       touch file
       wrfile file -n 1MB
       file-clone-create file clone
</pre>
<p></p>
<p>9. How does 'env-set --eof' work in an mse script?</p>
<p>Note that when "env-set --eof" is used in an mse script, the --eof option must be the last option before the variable name. This option behaves differently as follows.</p>
<p>9.1 Specify full option name, --eof, to avoid interactive data entry</p>
<pre>     server:$ sscat test.scr
     env-set --eof END username
     hoc
     END
</pre>
<p></p>
<pre>     server:$ mse -f test.scr
     server:$ env --terse --name username
     hoc
</pre>
<p></p>
<p>9.2 Specify partial option name, --eo, to allow interactive data entry</p>
<pre>     server:$ sscat test1.scr
     echo -n "Enter username followed by END marker to stop: "
     env-set --eo END username
     echo Done
     echo
</pre>
<p></p>
<pre>     server:$ mse -f test1.scr
     Enter username followed by END marker to stop: hoc
     END
     Done
</pre>
<p></p>
<pre>     server:$ env --terse --name username
     hoc
</pre>
<p></p>
<p>10. How does 'env-set --eof' work in an ssrun script?</p>
<p>The ssrun command does not process the --eof option to any commands, including env-set. Thus, the --eof option is always processed by the env-set command and the user has to enter data interactively when running an ssrun script.</p>
<h1>See Also</h1>
<p><a href="../../Dev/backquote.html">backquote</a> <a href="../../Filter/Dev/calculate.html">calculate</a> <a href="../../User/echo.html">echo</a> <a href="../../Dev/env.html">env</a> <a href="../../Dev/env-set.html">env-set</a> <a href="../../Filter/Dev/env-unset.html">env-unset</a> <a href="../../Filter/Dev/mse.html">mse</a> <a href="../../Topic/mse-env.html">mse-env</a> <a href="../../Filter/Dev/mse-set.html">mse-set</a> <a href="../../Filter/Dev/mse-unset.html">mse-unset</a> <a href="../../Topic/quoted-text.html">quoted-text</a> <a href="../../Filter/Dev/strtoken.html">strtoken</a></p>
<h1>Privilege Level</h1>
<p>Dev</p>
<blockquote></blockquote>
<!--End footer-->
</body>
</html>
